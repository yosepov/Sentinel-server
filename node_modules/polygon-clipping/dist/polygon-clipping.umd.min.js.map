{"version":3,"file":"polygon-clipping.umd.min.js","sources":["../node_modules/splaytree/dist/splay.esm.js","../src/bbox.js","../src/flp.js","../src/rounder.js","../src/vector.js","../src/sweep-event.js","../src/segment.js","../src/geom-in.js","../src/geom-out.js","../src/sweep-line.js","../src/operation.js","../src/index.js"],"sourcesContent":["/**\n * splaytree v3.0.1\n * Fast Splay tree for Node and browser\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\nclass Node {\r\n    constructor(key, data) {\r\n        this.next = null;\r\n        this.key = key;\r\n        this.data = data;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n}\n\n/* follows \"An implementation of top-down splaying\"\r\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n */\r\nfunction DEFAULT_COMPARE(a, b) {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n/**\r\n * Simple top down splay, not requiring i to be in the tree t.\r\n */\r\nfunction splay(i, t, comparator) {\r\n    const N = new Node(null, null);\r\n    let l = N;\r\n    let r = N;\r\n    while (true) {\r\n        const cmp = comparator(i, t.key);\r\n        //if (i < t.key) {\r\n        if (cmp < 0) {\r\n            if (t.left === null)\r\n                break;\r\n            //if (i < t.left.key) {\r\n            if (comparator(i, t.left.key) < 0) {\r\n                const y = t.left; /* rotate right */\r\n                t.left = y.right;\r\n                y.right = t;\r\n                t = y;\r\n                if (t.left === null)\r\n                    break;\r\n            }\r\n            r.left = t; /* link right */\r\n            r = t;\r\n            t = t.left;\r\n            //} else if (i > t.key) {\r\n        }\r\n        else if (cmp > 0) {\r\n            if (t.right === null)\r\n                break;\r\n            //if (i > t.right.key) {\r\n            if (comparator(i, t.right.key) > 0) {\r\n                const y = t.right; /* rotate left */\r\n                t.right = y.left;\r\n                y.left = t;\r\n                t = y;\r\n                if (t.right === null)\r\n                    break;\r\n            }\r\n            l.right = t; /* link left */\r\n            l = t;\r\n            t = t.right;\r\n        }\r\n        else\r\n            break;\r\n    }\r\n    /* assemble */\r\n    l.right = t.left;\r\n    r.left = t.right;\r\n    t.left = N.right;\r\n    t.right = N.left;\r\n    return t;\r\n}\r\nfunction insert(i, data, t, comparator) {\r\n    const node = new Node(i, data);\r\n    if (t === null) {\r\n        node.left = node.right = null;\r\n        return node;\r\n    }\r\n    t = splay(i, t, comparator);\r\n    const cmp = comparator(i, t.key);\r\n    if (cmp < 0) {\r\n        node.left = t.left;\r\n        node.right = t;\r\n        t.left = null;\r\n    }\r\n    else if (cmp >= 0) {\r\n        node.right = t.right;\r\n        node.left = t;\r\n        t.right = null;\r\n    }\r\n    return node;\r\n}\r\nfunction split(key, v, comparator) {\r\n    let left = null;\r\n    let right = null;\r\n    if (v) {\r\n        v = splay(key, v, comparator);\r\n        const cmp = comparator(v.key, key);\r\n        if (cmp === 0) {\r\n            left = v.left;\r\n            right = v.right;\r\n        }\r\n        else if (cmp < 0) {\r\n            right = v.right;\r\n            v.right = null;\r\n            left = v;\r\n        }\r\n        else {\r\n            left = v.left;\r\n            v.left = null;\r\n            right = v;\r\n        }\r\n    }\r\n    return { left, right };\r\n}\r\nfunction merge(left, right, comparator) {\r\n    if (right === null)\r\n        return left;\r\n    if (left === null)\r\n        return right;\r\n    right = splay(left.key, right, comparator);\r\n    right.left = left;\r\n    return right;\r\n}\r\n/**\r\n * Prints level of the tree\r\n */\r\nfunction printRow(root, prefix, isTail, out, printNode) {\r\n    if (root) {\r\n        out(`${prefix}${isTail ? '└── ' : '├── '}${printNode(root)}\\n`);\r\n        const indent = prefix + (isTail ? '    ' : '│   ');\r\n        if (root.left)\r\n            printRow(root.left, indent, false, out, printNode);\r\n        if (root.right)\r\n            printRow(root.right, indent, true, out, printNode);\r\n    }\r\n}\r\nclass Tree {\r\n    constructor(comparator = DEFAULT_COMPARE) {\r\n        this._root = null;\r\n        this._size = 0;\r\n        this._comparator = comparator;\r\n    }\r\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\r\n    insert(key, data) {\r\n        this._size++;\r\n        return this._root = insert(key, data, this._root, this._comparator);\r\n    }\r\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\r\n    add(key, data) {\r\n        const node = new Node(key, data);\r\n        if (this._root === null) {\r\n            node.left = node.right = null;\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        const comparator = this._comparator;\r\n        const t = splay(key, this._root, comparator);\r\n        const cmp = comparator(key, t.key);\r\n        if (cmp === 0)\r\n            this._root = t;\r\n        else {\r\n            if (cmp < 0) {\r\n                node.left = t.left;\r\n                node.right = t;\r\n                t.left = null;\r\n            }\r\n            else if (cmp > 0) {\r\n                node.right = t.right;\r\n                node.left = t;\r\n                t.right = null;\r\n            }\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        return this._root;\r\n    }\r\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\r\n    remove(key) {\r\n        this._root = this._remove(key, this._root, this._comparator);\r\n    }\r\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\r\n    _remove(i, t, comparator) {\r\n        let x;\r\n        if (t === null)\r\n            return null;\r\n        t = splay(i, t, comparator);\r\n        const cmp = comparator(i, t.key);\r\n        if (cmp === 0) { /* found it */\r\n            if (t.left === null) {\r\n                x = t.right;\r\n            }\r\n            else {\r\n                x = splay(i, t.left, comparator);\r\n                x.right = t.right;\r\n            }\r\n            this._size--;\r\n            return x;\r\n        }\r\n        return t; /* It wasn't there */\r\n    }\r\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\r\n    pop() {\r\n        let node = this._root;\r\n        if (node) {\r\n            while (node.left)\r\n                node = node.left;\r\n            this._root = splay(node.key, this._root, this._comparator);\r\n            this._root = this._remove(node.key, this._root, this._comparator);\r\n            return { key: node.key, data: node.data };\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Find without splaying\r\n     */\r\n    findStatic(key) {\r\n        let current = this._root;\r\n        const compare = this._comparator;\r\n        while (current) {\r\n            const cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return current;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return null;\r\n    }\r\n    find(key) {\r\n        if (this._root) {\r\n            this._root = splay(key, this._root, this._comparator);\r\n            if (this._comparator(key, this._root.key) !== 0)\r\n                return null;\r\n        }\r\n        return this._root;\r\n    }\r\n    contains(key) {\r\n        let current = this._root;\r\n        const compare = this._comparator;\r\n        while (current) {\r\n            const cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return true;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return false;\r\n    }\r\n    forEach(visitor, ctx) {\r\n        let current = this._root;\r\n        const Q = []; /* Initialize stack s */\r\n        let done = false;\r\n        while (!done) {\r\n            if (current !== null) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length !== 0) {\r\n                    current = Q.pop();\r\n                    visitor.call(ctx, current);\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\r\n    range(low, high, fn, ctx) {\r\n        const Q = [];\r\n        const compare = this._comparator;\r\n        let node = this._root;\r\n        let cmp;\r\n        while (Q.length !== 0 || node) {\r\n            if (node) {\r\n                Q.push(node);\r\n                node = node.left;\r\n            }\r\n            else {\r\n                node = Q.pop();\r\n                cmp = compare(node.key, high);\r\n                if (cmp > 0) {\r\n                    break;\r\n                }\r\n                else if (compare(node.key, low) >= 0) {\r\n                    if (fn.call(ctx, node))\r\n                        return this; // stop if smth is returned\r\n                }\r\n                node = node.right;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns array of keys\r\n     */\r\n    keys() {\r\n        const keys = [];\r\n        this.forEach(({ key }) => keys.push(key));\r\n        return keys;\r\n    }\r\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\r\n    values() {\r\n        const values = [];\r\n        this.forEach(({ data }) => values.push(data));\r\n        return values;\r\n    }\r\n    min() {\r\n        if (this._root)\r\n            return this.minNode(this._root).key;\r\n        return null;\r\n    }\r\n    max() {\r\n        if (this._root)\r\n            return this.maxNode(this._root).key;\r\n        return null;\r\n    }\r\n    minNode(t = this._root) {\r\n        if (t)\r\n            while (t.left)\r\n                t = t.left;\r\n        return t;\r\n    }\r\n    maxNode(t = this._root) {\r\n        if (t)\r\n            while (t.right)\r\n                t = t.right;\r\n        return t;\r\n    }\r\n    /**\r\n     * Returns node at given index\r\n     */\r\n    at(index) {\r\n        let current = this._root;\r\n        let done = false;\r\n        let i = 0;\r\n        const Q = [];\r\n        while (!done) {\r\n            if (current) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length > 0) {\r\n                    current = Q.pop();\r\n                    if (i === index)\r\n                        return current;\r\n                    i++;\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    next(d) {\r\n        let root = this._root;\r\n        let successor = null;\r\n        if (d.right) {\r\n            successor = d.right;\r\n            while (successor.left)\r\n                successor = successor.left;\r\n            return successor;\r\n        }\r\n        const comparator = this._comparator;\r\n        while (root) {\r\n            const cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0) {\r\n                successor = root;\r\n                root = root.left;\r\n            }\r\n            else\r\n                root = root.right;\r\n        }\r\n        return successor;\r\n    }\r\n    prev(d) {\r\n        let root = this._root;\r\n        let predecessor = null;\r\n        if (d.left !== null) {\r\n            predecessor = d.left;\r\n            while (predecessor.right)\r\n                predecessor = predecessor.right;\r\n            return predecessor;\r\n        }\r\n        const comparator = this._comparator;\r\n        while (root) {\r\n            const cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0)\r\n                root = root.left;\r\n            else {\r\n                predecessor = root;\r\n                root = root.right;\r\n            }\r\n        }\r\n        return predecessor;\r\n    }\r\n    clear() {\r\n        this._root = null;\r\n        this._size = 0;\r\n        return this;\r\n    }\r\n    toList() {\r\n        return toList(this._root);\r\n    }\r\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\r\n    load(keys, values = [], presort = false) {\r\n        let size = keys.length;\r\n        const comparator = this._comparator;\r\n        // sort if needed\r\n        if (presort)\r\n            sort(keys, values, 0, size - 1, comparator);\r\n        if (this._root === null) { // empty tree\r\n            this._root = loadRecursive(keys, values, 0, size);\r\n            this._size = size;\r\n        }\r\n        else { // that re-builds the whole tree from two in-order traversals\r\n            const mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\r\n            size = this._size + size;\r\n            this._root = sortedListToBST({ head: mergedList }, 0, size);\r\n        }\r\n        return this;\r\n    }\r\n    isEmpty() { return this._root === null; }\r\n    get size() { return this._size; }\r\n    get root() { return this._root; }\r\n    toString(printNode = (n) => String(n.key)) {\r\n        const out = [];\r\n        printRow(this._root, '', true, (v) => out.push(v), printNode);\r\n        return out.join('');\r\n    }\r\n    update(key, newKey, newData) {\r\n        const comparator = this._comparator;\r\n        let { left, right } = split(key, this._root, comparator);\r\n        if (comparator(key, newKey) < 0) {\r\n            right = insert(newKey, newData, right, comparator);\r\n        }\r\n        else {\r\n            left = insert(newKey, newData, left, comparator);\r\n        }\r\n        this._root = merge(left, right, comparator);\r\n    }\r\n    split(key) {\r\n        return split(key, this._root, this._comparator);\r\n    }\r\n}\r\nfunction loadRecursive(keys, values, start, end) {\r\n    const size = end - start;\r\n    if (size > 0) {\r\n        const middle = start + Math.floor(size / 2);\r\n        const key = keys[middle];\r\n        const data = values[middle];\r\n        const node = new Node(key, data);\r\n        node.left = loadRecursive(keys, values, start, middle);\r\n        node.right = loadRecursive(keys, values, middle + 1, end);\r\n        return node;\r\n    }\r\n    return null;\r\n}\r\nfunction createList(keys, values) {\r\n    const head = new Node(null, null);\r\n    let p = head;\r\n    for (let i = 0; i < keys.length; i++) {\r\n        p = p.next = new Node(keys[i], values[i]);\r\n    }\r\n    p.next = null;\r\n    return head.next;\r\n}\r\nfunction toList(root) {\r\n    let current = root;\r\n    const Q = [];\r\n    let done = false;\r\n    const head = new Node(null, null);\r\n    let p = head;\r\n    while (!done) {\r\n        if (current) {\r\n            Q.push(current);\r\n            current = current.left;\r\n        }\r\n        else {\r\n            if (Q.length > 0) {\r\n                current = p = p.next = Q.pop();\r\n                current = current.right;\r\n            }\r\n            else\r\n                done = true;\r\n        }\r\n    }\r\n    p.next = null; // that'll work even if the tree was empty\r\n    return head.next;\r\n}\r\nfunction sortedListToBST(list, start, end) {\r\n    const size = end - start;\r\n    if (size > 0) {\r\n        const middle = start + Math.floor(size / 2);\r\n        const left = sortedListToBST(list, start, middle);\r\n        const root = list.head;\r\n        root.left = left;\r\n        list.head = list.head.next;\r\n        root.right = sortedListToBST(list, middle + 1, end);\r\n        return root;\r\n    }\r\n    return null;\r\n}\r\nfunction mergeLists(l1, l2, compare) {\r\n    const head = new Node(null, null); // dummy\r\n    let p = head;\r\n    let p1 = l1;\r\n    let p2 = l2;\r\n    while (p1 !== null && p2 !== null) {\r\n        if (compare(p1.key, p2.key) < 0) {\r\n            p.next = p1;\r\n            p1 = p1.next;\r\n        }\r\n        else {\r\n            p.next = p2;\r\n            p2 = p2.next;\r\n        }\r\n        p = p.next;\r\n    }\r\n    if (p1 !== null) {\r\n        p.next = p1;\r\n    }\r\n    else if (p2 !== null) {\r\n        p.next = p2;\r\n    }\r\n    return head.next;\r\n}\r\nfunction sort(keys, values, left, right, compare) {\r\n    if (left >= right)\r\n        return;\r\n    const pivot = keys[(left + right) >> 1];\r\n    let i = left - 1;\r\n    let j = right + 1;\r\n    while (true) {\r\n        do\r\n            i++;\r\n        while (compare(keys[i], pivot) < 0);\r\n        do\r\n            j--;\r\n        while (compare(keys[j], pivot) > 0);\r\n        if (i >= j)\r\n            break;\r\n        let tmp = keys[i];\r\n        keys[i] = keys[j];\r\n        keys[j] = tmp;\r\n        tmp = values[i];\r\n        values[i] = values[j];\r\n        values[j] = tmp;\r\n    }\r\n    sort(keys, values, left, j, compare);\r\n    sort(keys, values, j + 1, right, compare);\r\n}\n\nexport default Tree;\n//# sourceMappingURL=splay.esm.js.map\n","/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\n\nexport const isInBbox = (bbox, point) => {\n  return (\n    (bbox.ll.x <= point.x) &&\n    (point.x <= bbox.ur.x) &&\n    (bbox.ll.y <= point.y) &&\n    (point.y <= bbox.ur.y)\n  )\n}\n\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\nexport const getBboxOverlap = (b1, b2) => {\n  // check if the bboxes overlap at all\n  if (\n    b2.ur.x < b1.ll.x ||\n    b1.ur.x < b2.ll.x ||\n    b2.ur.y < b1.ll.y ||\n    b1.ur.y < b2.ll.y\n  ) return null\n\n  // find the middle two X values\n  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x\n  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x\n\n  // find the middle two Y values\n  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y\n  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y\n\n  // put those middle values together to get the overlap\n  return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } }\n}\n","/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\n\nlet epsilon = Number.EPSILON\n\n// IE Polyfill\nif (epsilon === undefined) epsilon = Math.pow(2, -52)\n\nconst EPSILON_SQ = epsilon * epsilon\n\n/* FLP comparator */\nexport const cmp = (a, b) => {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0\n    }\n  }\n\n  // check if they're flp equal\n  const ab = a - b\n  if (ab * ab < EPSILON_SQ * a * b) {\n    return 0\n  }\n\n  // normal comparison\n  return a < b ? -1 : 1\n}\n","import { cmp } from './flp'\nimport SplayTree from 'splaytree'\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nclass PtRounder {\n  constructor () {\n    this.reset()\n  }\n\n  reset () {\n    this.xRounder = new CoordRounder()\n    this.yRounder = new CoordRounder()\n  }\n\n  round (x, y) {\n    return {\n      x: this.xRounder.round(x),\n      y: this.yRounder.round(y),\n    }\n  }\n}\n\nclass CoordRounder {\n  constructor () {\n    this.tree = new SplayTree()\n    // preseed with 0 so we don't end up with values < Number.EPSILON\n    this.round(0)\n  }\n\n  // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n  round (coord) {\n    const node = this.tree.add(coord)\n\n    const prevNode = this.tree.prev(node)\n    if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n      this.tree.remove(coord)\n      return prevNode.key\n    }\n\n    const nextNode = this.tree.next(node)\n    if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n      this.tree.remove(coord)\n      return nextNode.key\n    }\n\n    return coord\n  }\n}\n\n// singleton available by import\nconst rounder = new PtRounder()\n\nexport default rounder\n","import { cmp } from './flp'\n\n/* Cross Product of two vectors with first point at origin */\nexport const crossProduct = (a, b) => a.x * b.y - a.y * b.x\n\n/* Dot Product of two vectors with first point at origin */\nexport const dotProduct = (a, b) => a.x * b.x + a.y * b.y\n\n/* Comparator for two vectors with same starting point */\nexport const compareVectorAngles = (basePt, endPt1, endPt2) => {\n  const v1 = { x: endPt1.x - basePt.x, y: endPt1.y - basePt.y }\n  const v2 = { x: endPt2.x - basePt.x, y: endPt2.y - basePt.y }\n  const kross = crossProduct(v1, v2)\n  return cmp(kross, 0)\n}\n\nexport const length = v => Math.sqrt(dotProduct(v, v))\n\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\nexport const sineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y }\n  const vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y }\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase)\n}\n\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\nexport const cosineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = { x: pBase.x - pShared.x, y: pBase.y - pShared.y }\n  const vAngle = { x: pAngle.x - pShared.x, y: pAngle.y - pShared.y }\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase)\n}\n\n/* Get the closest point on an line (defined by two points)\n * to another point. */\nexport const closestPoint = (ptA1, ptA2, ptB) => {\n  if (ptA1.x === ptA2.x) return { x: ptA1.x, y: ptB.y } // vertical vector\n  if (ptA1.y === ptA2.y) return { x: ptB.x, y: ptA1.y } // horizontal vector\n\n  // determinne which point is further away\n  // we use the further point as our base in the calculation, so that the\n  // vectors are more parallel, providing more accurate dot product\n  const v1 = { x: ptB.x - ptA1.x, y: ptB.y - ptA1.y }\n  const v2 = { x: ptB.x - ptA2.x, y: ptB.y - ptA2.y }\n  let vFar, vA, farPt\n  if (dotProduct(v1, v1) > dotProduct(v2, v2)) {\n    vFar = v1\n    vA = { x: ptA2.x - ptA1.x, y: ptA2.y - ptA1.y }\n    farPt = ptA1\n  }\n  else {\n    vFar = v2\n    vA = { x: ptA1.x - ptA2.x, y: ptA1.y - ptA2.y }\n    farPt = ptA2\n  }\n\n  // manually test if the current point can be considered to be on the line\n  // If the X coordinate was on the line, would the Y coordinate be as well?\n  const xDist = (ptB.x - farPt.x) / vA.x\n  if (ptB.y === farPt.y + xDist * vA.y) return ptB\n\n  // If the Y coordinate was on the line, would the X coordinate be as well?\n  const yDist = (ptB.y - farPt.y) / vA.y\n  if (ptB.x === farPt.x + yDist * vA.x) return ptB\n\n  // current point isn't exactly on line, so return closest point\n  const dist = dotProduct(vA, vFar) / dotProduct(vA, vA)\n  return { x: farPt.x + dist * vA.x, y: farPt.y + dist * vA.y }\n}\n\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const horizontalIntersection = (pt, v, y) => {\n  if (v.y === 0) return null\n  return { x: pt.x + v.x / v.y * ( y - pt.y ), y: y }\n}\n\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const verticalIntersection = (pt, v, x) => {\n  if (v.x === 0) return null\n  return { x: x, y: pt.y + v.y / v.x * ( x - pt.x ) }\n}\n\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nexport const intersection = (pt1, v1, pt2, v2) => {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x)\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x)\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y)\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y)\n\n  // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  const kross = crossProduct(v1, v2)\n  if (kross == 0) return null\n\n  const ve = { x: pt2.x - pt1.x, y: pt2.y - pt1.y }\n  const d1 = crossProduct(ve, v1) / kross\n  const d2 = crossProduct(ve, v2) / kross\n\n  // take the average of the two calculations to minimize rounding error\n  const x1 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x\n  const y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y\n  const x = (x1 + x2) / 2\n  const y = (y1 + y2) / 2\n  return { x: x, y: y }\n}\n\n/* Given a vector, return one that is perpendicular */\nexport const perpendicular = (v) => {\n  return { x: -v.y, y: v.x }\n}\n","import Segment from './segment'\nimport { cosineOfAngle, sineOfAngle } from './vector'\n\nexport default class SweepEvent {\n\n  // for ordering sweep events in the sweep event queue\n  static compare (a, b) {\n\n    // favor event with a point that the sweep line hits first\n    const ptCmp = SweepEvent.comparePoints(a.point, b.point)\n    if (ptCmp !== 0) return ptCmp\n\n    // the points are the same, so link them if needed\n    if (a.point !== b.point) a.link(b)\n\n    // favor right events over left\n    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1\n\n    // we have two matching left or right endpoints\n    // ordering of this case is the same as for their segments\n    return Segment.compare(a.segment, b.segment)\n  }\n\n  // for ordering points in sweep line order\n  static comparePoints (aPt, bPt) {\n    if (aPt.x < bPt.x) return -1\n    if (aPt.x > bPt.x) return 1\n\n    if (aPt.y < bPt.y) return -1\n    if (aPt.y > bPt.y) return 1\n\n    return 0\n  }\n\n  // Warning: 'point' input will be modified and re-used (for performance)\n  constructor (point, isLeft) {\n    if (point.events === undefined) point.events = [this]\n    else point.events.push(this)\n    this.point = point\n    this.isLeft = isLeft\n    // this.segment, this.otherSE set by factory\n  }\n\n  link (other) {\n    if (other.point === this.point) {\n      throw new Error('Tried to link already linked events')\n    }\n    const otherEvents = other.point.events\n    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n      const evt = otherEvents[i]\n      this.point.events.push(evt)\n      evt.point = this.point\n    }\n    this.checkForConsuming()\n  }\n\n  /* Do a pass over our linked events and check to see if any pair\n   * of segments match, and should be consumed. */\n  checkForConsuming () {\n    // FIXME: The loops in this method run O(n^2) => no good.\n    //        Maintain little ordered sweep event trees?\n    //        Can we maintaining an ordering that avoids the need\n    //        for the re-sorting with getLeftmostComparator in geom-out?\n\n    // Compare each pair of events to see if other events also match\n    const numEvents = this.point.events.length\n    for (let i = 0; i < numEvents; i++) {\n      const evt1 = this.point.events[i]\n      if (evt1.segment.consumedBy !== undefined) continue\n      for (let j = i + 1; j < numEvents; j++) {\n        const evt2 = this.point.events[j]\n        if (evt2.consumedBy !== undefined) continue\n        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue\n        evt1.segment.consume(evt2.segment)\n      }\n    }\n  }\n\n  getAvailableLinkedEvents () {\n    // point.events is always of length 2 or greater\n    const events = []\n    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n      const evt = this.point.events[i]\n      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n        events.push(evt)\n      }\n    }\n    return events\n  }\n\n  /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */\n  getLeftmostComparator (baseEvent) {\n    const cache = new Map()\n\n    const fillCache = linkedEvent => {\n      const nextEvent = linkedEvent.otherSE\n      cache.set(linkedEvent, {\n        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n      })\n    }\n\n    return (a, b) => {\n      if (!cache.has(a)) fillCache(a)\n      if (!cache.has(b)) fillCache(b)\n\n      const { sine: asine, cosine: acosine } = cache.get(a)\n      const { sine: bsine, cosine: bcosine } = cache.get(b)\n\n      // both on or above x-axis\n      if (asine >= 0 && bsine >= 0) {\n        if (acosine < bcosine) return 1\n        if (acosine > bcosine) return -1\n        return 0\n      }\n\n      // both below x-axis\n      if (asine < 0 && bsine < 0) {\n        if (acosine < bcosine) return -1\n        if (acosine > bcosine) return 1\n        return 0\n      }\n\n      // one above x-axis, one below\n      if (bsine < asine) return -1\n      if (bsine > asine) return 1\n      return 0\n    }\n  }\n}\n","import operation from './operation'\nimport SweepEvent from './sweep-event'\nimport { isInBbox, getBboxOverlap } from './bbox'\nimport { intersection } from './vector'\nimport rounder from './rounder'\n\n// Give segments unique ID's to get consistent sorting of\n// segments and sweep events when all else is identical\nlet segmentId = 0\n\nexport default class Segment {\n\n  /* This compare() function is for ordering segments in the sweep\n   * line tree, and does so according to the following criteria:\n   *\n   * Consider the vertical line that lies an infinestimal step to the\n   * right of the right-more of the two left endpoints of the input\n   * segments. Imagine slowly moving a point up from negative infinity\n   * in the increasing y direction. Which of the two segments will that\n   * point intersect first? That segment comes 'before' the other one.\n   *\n   * If neither segment would be intersected by such a line, (if one\n   * or more of the segments are vertical) then the line to be considered\n   * is directly on the right-more of the two left inputs.\n   */\n  static compare (a, b) {\n\n    const alx = a.leftSE.point.x\n    const blx = b.leftSE.point.x\n    const arx = a.rightSE.point.x\n    const brx = b.rightSE.point.x\n\n    // check if they're even in the same vertical plane\n    if (brx < alx) return 1\n    if (arx < blx) return -1\n\n    const aly = a.leftSE.point.y\n    const bly = b.leftSE.point.y\n    const ary = a.rightSE.point.y\n    const bry = b.rightSE.point.y\n\n    // is left endpoint of segment B the right-more?\n    if (alx < blx) {\n      // are the two segments in the same horizontal plane?\n      if (bly < aly && bly < ary) return 1\n      if (bly > aly && bly > ary) return -1\n\n      // is the B left endpoint colinear to segment A?\n      const aCmpBLeft = a.comparePoint(b.leftSE.point)\n      if (aCmpBLeft < 0) return 1\n      if (aCmpBLeft > 0) return -1\n\n      // is the A right endpoint colinear to segment B ?\n      const bCmpARight = b.comparePoint(a.rightSE.point)\n      if (bCmpARight !== 0) return bCmpARight\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return -1\n    }\n\n    // is left endpoint of segment A the right-more?\n    if (alx > blx) {\n      if (aly < bly && aly < bry) return -1\n      if (aly > bly && aly > bry) return 1\n\n      // is the A left endpoint colinear to segment B?\n      const bCmpALeft = b.comparePoint(a.leftSE.point)\n      if (bCmpALeft !== 0) return bCmpALeft\n\n      // is the B right endpoint colinear to segment A?\n      const aCmpBRight = a.comparePoint(b.rightSE.point)\n      if (aCmpBRight < 0) return 1\n      if (aCmpBRight > 0) return -1\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return 1\n    }\n\n    // if we get here, the two left endpoints are in the same\n    // vertical plane, ie alx === blx\n\n    // consider the lower left-endpoint to come first\n    if (aly < bly) return -1\n    if (aly > bly) return 1\n\n    // left endpoints are identical\n    // check for colinearity by using the left-more right endpoint\n\n    // is the A right endpoint more left-more?\n    if (arx < brx) {\n      const bCmpARight = b.comparePoint(a.rightSE.point)\n      if (bCmpARight !== 0) return bCmpARight\n    }\n\n    // is the B right endpoint more left-more?\n    if (arx > brx) {\n      const aCmpBRight = a.comparePoint(b.rightSE.point)\n      if (aCmpBRight < 0) return 1\n      if (aCmpBRight > 0) return -1\n    }\n\n    if (arx !== brx)  {\n      // are these two [almost] vertical segments with opposite orientation?\n      // if so, the one with the lower right endpoint comes first\n      const ay = ary - aly\n      const ax = arx - alx\n      const by = bry - bly\n      const bx = brx - blx\n      if (ay > ax && by < bx) return 1\n      if (ay < ax && by > bx) return -1\n    }\n\n    // we have colinear segments with matching orientation\n    // consider the one with more left-more right endpoint to be first\n    if (arx > brx) return 1\n    if (arx < brx) return -1\n\n    // if we get here, two two right endpoints are in the same\n    // vertical plane, ie arx === brx\n\n    // consider the lower right-endpoint to come first\n    if (ary < bry) return -1\n    if (ary > bry) return 1\n\n    // right endpoints identical as well, so the segments are idential\n    // fall back on creation order as consistent tie-breaker\n    if (a.id < b.id) return -1\n    if (a.id > b.id) return 1\n\n    // identical segment, ie a === b\n    return 0\n  }\n\n  /* Warning: a reference to ringWindings input will be stored,\n   *  and possibly will be later modified */\n  constructor (leftSE, rightSE, rings, windings) {\n    this.id = ++segmentId\n    this.leftSE = leftSE\n    leftSE.segment = this\n    leftSE.otherSE = rightSE\n    this.rightSE = rightSE\n    rightSE.segment = this\n    rightSE.otherSE = leftSE\n    this.rings = rings\n    this.windings = windings\n    // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n\n  static fromRing(pt1, pt2, ring) {\n    let leftPt, rightPt, winding\n\n    // ordering the two points according to sweep line ordering\n    const cmpPts = SweepEvent.comparePoints(pt1, pt2)\n    if (cmpPts < 0) {\n      leftPt = pt1\n      rightPt = pt2\n      winding = 1\n    }\n    else if (cmpPts > 0) {\n      leftPt = pt2\n      rightPt = pt1\n      winding = -1\n    }\n    else throw new Error(\n      `Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`\n    )\n\n    const leftSE = new SweepEvent(leftPt, true)\n    const rightSE = new SweepEvent(rightPt, false)\n    return new Segment(leftSE, rightSE, [ring], [winding])\n  }\n\n  /* When a segment is split, the rightSE is replaced with a new sweep event */\n  replaceRightSE (newRightSE) {\n    this.rightSE = newRightSE\n    this.rightSE.segment = this\n    this.rightSE.otherSE = this.leftSE\n    this.leftSE.otherSE = this.rightSE\n  }\n\n  bbox () {\n    const y1 = this.leftSE.point.y\n    const y2 = this.rightSE.point.y\n    return {\n      ll: { x: this.leftSE.point.x, y: y1 < y2 ? y1 : y2 },\n      ur: { x: this.rightSE.point.x, y: y1 > y2 ? y1 : y2 }\n    }\n  }\n\n  /* A vector from the left point to the right */\n  vector () {\n    return {\n      x: this.rightSE.point.x - this.leftSE.point.x,\n      y: this.rightSE.point.y - this.leftSE.point.y\n    }\n  }\n\n  isAnEndpoint (pt) {\n    return (\n      (pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y) ||\n      (pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y)\n    )\n  }\n\n  /* Compare this segment with a point.\n   *\n   * A point P is considered to be colinear to a segment if there\n   * exists a distance D such that if we travel along the segment\n   * from one * endpoint towards the other a distance D, we find\n   * ourselves at point P.\n   *\n   * Return value indicates:\n   *\n   *   1: point lies above the segment (to the left of vertical)\n   *   0: point is colinear to segment\n   *  -1: point lies below the segment (to the right of vertical)\n   */\n  comparePoint (point) {\n    if (this.isAnEndpoint(point)) return 0\n\n    const lPt = this.leftSE.point\n    const rPt = this.rightSE.point\n    const v = this.vector()\n\n    // Exactly vertical segments.\n    if (lPt.x === rPt.x) {\n      if (point.x === lPt.x) return 0\n      return point.x < lPt.x ? 1 : -1\n    }\n\n    // Nearly vertical segments with an intersection.\n    // Check to see where a point on the line with matching Y coordinate is.\n    const yDist = (point.y - lPt.y) / v.y\n    const xFromYDist = lPt.x + yDist * v.x\n    if (point.x === xFromYDist) return 0\n\n    // General case.\n    // Check to see where a point on the line with matching X coordinate is.\n    const xDist =  (point.x - lPt.x) / v.x\n    const yFromXDist = lPt.y + xDist * v.y\n    if (point.y === yFromXDist) return 0\n    return point.y < yFromXDist ? -1 : 1\n  }\n\n  /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */\n  getIntersection (other) {\n    // If bboxes don't overlap, there can't be any intersections\n    const tBbox = this.bbox()\n    const oBbox = other.bbox()\n    const bboxOverlap = getBboxOverlap(tBbox, oBbox)\n    if (bboxOverlap === null) return null\n\n    // We first check to see if the endpoints can be considered intersections.\n    // This will 'snap' intersections to endpoints if possible, and will\n    // handle cases of colinearity.\n\n    const tlp = this.leftSE.point\n    const trp = this.rightSE.point\n    const olp = other.leftSE.point\n    const orp = other.rightSE.point\n\n    // does each endpoint touch the other segment?\n    // note that we restrict the 'touching' definition to only allow segments\n    // to touch endpoints that lie forward from where we are in the sweep line pass\n    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0\n    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0\n    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0\n    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0\n\n    // do left endpoints match?\n    if (touchesThisLSE && touchesOtherLSE) {\n      // these two cases are for colinear segments with matching left\n      // endpoints, and one segment being longer than the other\n      if (touchesThisRSE && !touchesOtherRSE) return trp\n      if (!touchesThisRSE && touchesOtherRSE) return orp\n      // either the two segments match exactly (two trival intersections)\n      // or just on their left endpoint (one trivial intersection\n      return null\n    }\n\n    // does this left endpoint matches (other doesn't)\n    if (touchesThisLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesOtherRSE) {\n        if (tlp.x === orp.x && tlp.y === orp.y) return null\n      }\n      // t-intersection on left endpoint\n      return tlp\n    }\n\n    // does other left endpoint matches (this doesn't)\n    if (touchesOtherLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesThisRSE) {\n        if (trp.x === olp.x && trp.y === olp.y) return null\n      }\n      // t-intersection on left endpoint\n      return olp\n    }\n\n    // trivial intersection on right endpoints\n    if (touchesThisRSE && touchesOtherRSE) return null\n\n    // t-intersections on just one right endpoint\n    if (touchesThisRSE) return trp\n    if (touchesOtherRSE) return orp\n\n    // None of our endpoints intersect. Look for a general intersection between\n    // infinite lines laid over the segments\n    const pt = intersection(tlp, this.vector(), olp, other.vector())\n\n    // are the segments parrallel? Note that if they were colinear with overlap,\n    // they would have an endpoint intersection and that case was already handled above\n    if (pt === null) return null\n\n    // is the intersection found between the lines not on the segments?\n    if (!isInBbox(bboxOverlap, pt)) return null\n\n    // round the the computed point if needed\n    return rounder.round(pt.x, pt.y)\n  }\n\n  /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */\n  split (point) {\n    const newEvents = []\n    const alreadyLinked = point.events !== undefined\n\n    const newLeftSE = new SweepEvent(point, true)\n    const newRightSE = new SweepEvent(point, false)\n    const oldRightSE = this.rightSE\n    this.replaceRightSE(newRightSE)\n    newEvents.push(newRightSE)\n    newEvents.push(newLeftSE)\n    const newSeg = new Segment(\n      newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()\n    )\n\n    // when splitting a nearly vertical downward-facing segment,\n    // sometimes one of the resulting new segments is vertical, in which\n    // case its left and right events may need to be swapped\n    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n      newSeg.swapEvents()\n    }\n    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n      this.swapEvents()\n    }\n\n    // in the point we just used to create new sweep events with was already\n    // linked to other events, we need to check if either of the affected\n    // segments should be consumed\n    if (alreadyLinked) {\n      newLeftSE.checkForConsuming()\n      newRightSE.checkForConsuming()\n    }\n\n    return newEvents\n  }\n\n  /* Swap which event is left and right */\n  swapEvents () {\n    const tmpEvt = this.rightSE\n    this.rightSE = this.leftSE\n    this.leftSE = tmpEvt\n    this.leftSE.isLeft = true\n    this.rightSE.isLeft = false\n    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n      this.windings[i] *= -1\n    }\n  }\n\n  /* Consume another segment. We take their rings under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */\n  consume (other) {\n    let consumer = this\n    let consumee = other\n    while (consumer.consumedBy) consumer = consumer.consumedBy\n    while (consumee.consumedBy) consumee = consumee.consumedBy\n\n    const cmp = Segment.compare(consumer, consumee)\n    if (cmp === 0) return  // already consumed\n    // the winner of the consumption is the earlier segment\n    // according to sweep line ordering\n    if (cmp  > 0) {\n      const tmp = consumer\n      consumer = consumee\n      consumee = tmp\n    }\n\n    // make sure a segment doesn't consume it's prev\n    if (consumer.prev === consumee) {\n      const tmp = consumer\n      consumer = consumee\n      consumee = tmp\n    }\n\n    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n      const ring = consumee.rings[i]\n      const winding = consumee.windings[i]\n      const index = consumer.rings.indexOf(ring)\n      if (index === -1) {\n        consumer.rings.push(ring)\n        consumer.windings.push(winding)\n      }\n      else consumer.windings[index] += winding\n    }\n    consumee.rings = null\n    consumee.windings = null\n    consumee.consumedBy = consumer\n\n    // mark sweep events consumed as to maintain ordering in sweep event queue\n    consumee.leftSE.consumedBy = consumer.leftSE\n    consumee.rightSE.consumedBy = consumer.rightSE\n  }\n\n  /* The first segment previous segment chain that is in the result */\n  prevInResult () {\n    if (this._prevInResult !== undefined) return this._prevInResult\n    if (! this.prev) this._prevInResult = null\n    else if (this.prev.isInResult()) this._prevInResult = this.prev\n    else this._prevInResult = this.prev.prevInResult()\n    return this._prevInResult\n  }\n\n  beforeState() {\n    if (this._beforeState !== undefined) return this._beforeState\n    if (! this.prev) this._beforeState = {\n      rings: [],\n      windings: [],\n      multiPolys: [],\n    }\n    else {\n      const seg = this.prev.consumedBy || this.prev\n      this._beforeState = seg.afterState()\n    }\n    return this._beforeState\n  }\n\n  afterState () {\n    if (this._afterState !== undefined) return this._afterState\n\n    const beforeState = this.beforeState()\n    this._afterState = {\n      rings: beforeState.rings.slice(0),\n      windings: beforeState.windings.slice(0),\n      multiPolys: []\n    }\n    const ringsAfter = this._afterState.rings\n    const windingsAfter = this._afterState.windings\n    const mpsAfter = this._afterState.multiPolys\n\n    // calculate ringsAfter, windingsAfter\n    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n      const ring = this.rings[i]\n      const winding = this.windings[i]\n      const index = ringsAfter.indexOf(ring)\n      if (index === -1) {\n        ringsAfter.push(ring)\n        windingsAfter.push(winding)\n      }\n      else windingsAfter[index] += winding\n    }\n\n    // calcualte polysAfter\n    const polysAfter = []\n    const polysExclude = []\n    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n      if (windingsAfter[i] === 0) continue // non-zero rule\n      const ring = ringsAfter[i]\n      const poly = ring.poly\n      if (polysExclude.indexOf(poly) !== -1) continue\n      if (ring.isExterior) polysAfter.push(poly)\n      else {\n        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly)\n        const index = polysAfter.indexOf(ring.poly)\n        if (index !== -1) polysAfter.splice(index, 1)\n      }\n    }\n\n    // calculate multiPolysAfter\n    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n      const mp = polysAfter[i].multiPoly\n      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp)\n    }\n\n    return this._afterState\n  }\n\n  /* Is this segment part of the final result? */\n  isInResult () {\n    // if we've been consumed, we're not in the result\n    if (this.consumedBy) return false\n\n    if (this._isInResult !== undefined) return this._isInResult\n\n    const mpsBefore = this.beforeState().multiPolys\n    const mpsAfter = this.afterState().multiPolys\n\n    switch (operation.type) {\n      case 'union': {\n        // UNION - included iff:\n        //  * On one side of us there is 0 poly interiors AND\n        //  * On the other side there is 1 or more.\n        const noBefores = mpsBefore.length === 0\n        const noAfters = mpsAfter.length === 0\n        this._isInResult = noBefores !== noAfters\n        break\n      }\n\n      case 'intersection': {\n        // INTERSECTION - included iff:\n        //  * on one side of us all multipolys are rep. with poly interiors AND\n        //  * on the other side of us, not all multipolys are repsented\n        //    with poly interiors\n        let least\n        let most\n        if (mpsBefore.length < mpsAfter.length) {\n          least = mpsBefore.length\n          most = mpsAfter.length\n        } else {\n          least = mpsAfter.length\n          most = mpsBefore.length\n        }\n        this._isInResult = most === operation.numMultiPolys && least < most\n        break\n      }\n\n      case 'xor': {\n        // XOR - included iff:\n        //  * the difference between the number of multipolys represented\n        //    with poly interiors on our two sides is an odd number\n        const diff = Math.abs(mpsBefore.length - mpsAfter.length)\n        this._isInResult = diff % 2 === 1\n        break\n      }\n\n      case 'difference': {\n        // DIFFERENCE included iff:\n        //  * on exactly one side, we have just the subject\n        const isJustSubject = mps => mps.length === 1 && mps[0].isSubject\n        this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter)\n        break\n      }\n\n      default:\n        throw new Error(`Unrecognized operation type found ${operation.type}`)\n    }\n\n    return this._isInResult\n  }\n\n}\n","import rounder from './rounder'\nimport Segment from './segment'\n\nexport class RingIn {\n  constructor (geomRing, poly, isExterior) {\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon')\n    }\n\n    this.poly = poly\n    this.isExterior = isExterior\n    this.segments = []\n\n    if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon')\n    }\n\n    const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1])\n    this.bbox = {\n      ll: { x: firstPoint.x, y: firstPoint.y },\n      ur: { x: firstPoint.x, y: firstPoint.y },\n    }\n\n    let prevPoint = firstPoint\n    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon')\n      }\n      let point = rounder.round(geomRing[i][0], geomRing[i][1])\n      // skip repeated points\n      if (point.x === prevPoint.x && point.y === prevPoint.y) continue\n      this.segments.push(Segment.fromRing(prevPoint, point, this))\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y\n      prevPoint = point\n    }\n    // add segment from last to first if last is not the same as first\n    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this))\n    }\n  }\n\n  getSweepEvents () {\n    const sweepEvents = []\n    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n      const segment = this.segments[i]\n      sweepEvents.push(segment.leftSE)\n      sweepEvents.push(segment.rightSE)\n    }\n    return sweepEvents\n  }\n}\n\nexport class PolyIn {\n  constructor (geomPoly, multiPoly) {\n    if (!Array.isArray(geomPoly)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon')\n    }\n    this.exteriorRing = new RingIn(geomPoly[0], this, true)\n    // copy by value\n    this.bbox = {\n      ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },\n      ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y },\n    }\n    this.interiorRings = []\n    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      const ring = new RingIn(geomPoly[i], this, false)\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y\n      this.interiorRings.push(ring)\n    }\n    this.multiPoly = multiPoly\n  }\n\n  getSweepEvents () {\n    const sweepEvents = this.exteriorRing.getSweepEvents()\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringSweepEvents = this.interiorRings[i].getSweepEvents()\n      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(ringSweepEvents[j])\n      }\n    }\n    return sweepEvents\n  }\n}\n\nexport class MultiPolyIn {\n  constructor (geom, isSubject) {\n    if (!Array.isArray(geom)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon')\n    }\n\n    try {\n      // if the input looks like a polygon, convert it to a multipolygon\n      if (typeof geom[0][0][0] === 'number') geom = [geom]\n    } catch (ex) {\n      // The input is either malformed or has empty arrays.\n      // In either case, it will be handled later on.\n    }\n\n    this.polys = []\n    this.bbox = {\n      ll: { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY },\n      ur: { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY },\n    }\n    for (let i = 0, iMax = geom.length; i < iMax; i++) {\n      const poly = new PolyIn(geom[i], this)\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y\n      this.polys.push(poly)\n    }\n    this.isSubject = isSubject\n  }\n\n  getSweepEvents () {\n    const sweepEvents = []\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polySweepEvents = this.polys[i].getSweepEvents()\n      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(polySweepEvents[j])\n      }\n    }\n    return sweepEvents\n  }\n}\n","import { compareVectorAngles } from './vector'\nimport SweepEvent from './sweep-event'\n\nexport class RingOut {\n  /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */\n  static factory (allSegments) {\n    const ringsOut = []\n\n    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n      const segment = allSegments[i]\n      if (!segment.isInResult() || segment.ringOut) continue\n\n      let prevEvent = null\n      let event = segment.leftSE\n      let nextEvent = segment.rightSE\n      const events = [event]\n\n      const startingPoint = event.point\n      const intersectionLEs = []\n\n      /* Walk the chain of linked events to form a closed ring */\n      while (true) {\n        prevEvent = event\n        event = nextEvent\n        events.push(event)\n\n        /* Is the ring complete? */\n        if (event.point === startingPoint) break\n\n        while (true) {\n          const availableLEs = event.getAvailableLinkedEvents()\n\n          /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n           * part of the algorithm malfunctioned... please file a bug report. */\n          if (availableLEs.length === 0) {\n            const firstPt = events[0].point\n            const lastPt = events[events.length - 1].point\n            throw new Error(\n              `Unable to complete output ring starting at [${firstPt.x},` +\n                ` ${firstPt.y}]. Last matching segment found ends at` +\n                ` [${lastPt.x}, ${lastPt.y}].`\n            )\n          }\n\n          /* Only one way to go, so cotinue on the path */\n          if (availableLEs.length === 1) {\n            nextEvent = availableLEs[0].otherSE\n            break\n          }\n\n          /* We must have an intersection. Check for a completed loop */\n          let indexLE = null\n          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n            if (intersectionLEs[j].point === event.point) {\n              indexLE = j\n              break\n            }\n          }\n          /* Found a completed loop. Cut that off and make a ring */\n          if (indexLE !== null) {\n            const intersectionLE = intersectionLEs.splice(indexLE)[0]\n            const ringEvents = events.splice(intersectionLE.index)\n            ringEvents.unshift(ringEvents[0].otherSE)\n            ringsOut.push(new RingOut(ringEvents.reverse()))\n            continue\n          }\n          /* register the intersection */\n          intersectionLEs.push({\n            index: events.length,\n            point: event.point,\n          })\n          /* Choose the left-most option to continue the walk */\n          const comparator = event.getLeftmostComparator(prevEvent)\n          nextEvent = availableLEs.sort(comparator)[0].otherSE\n          break\n        }\n      }\n\n      ringsOut.push(new RingOut(events))\n    }\n    return ringsOut\n  }\n\n  constructor (events) {\n    this.events = events\n    for (let i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this\n    }\n    this.poly = null\n  }\n\n  getGeom () {\n    // Remove superfluous points (ie extra points along a straight line),\n    let prevPt = this.events[0].point\n    const points = [prevPt]\n    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n      const pt = this.events[i].point\n      const nextPt = this.events[i + 1].point\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue\n      points.push(pt)\n      prevPt = pt\n    }\n\n    // ring was all (within rounding error of angle calc) colinear points\n    if (points.length === 1) return null\n\n    // check if the starting point is necessary\n    const pt = points[0]\n    const nextPt = points[1]\n    if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift()\n\n    points.push(points[0])\n    const step = this.isExteriorRing() ? 1 : -1\n    const iStart = this.isExteriorRing() ? 0 : points.length - 1\n    const iEnd = this.isExteriorRing() ? points.length : -1\n    const orderedPoints = []\n    for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y])\n    return orderedPoints\n  }\n\n  isExteriorRing () {\n    if (this._isExteriorRing === undefined) {\n      const enclosing = this.enclosingRing()\n      this._isExteriorRing = enclosing ? ! enclosing.isExteriorRing() : true\n    }\n    return this._isExteriorRing\n  }\n\n  enclosingRing () {\n    if (this._enclosingRing === undefined) {\n      this._enclosingRing = this._calcEnclosingRing()\n    }\n    return this._enclosingRing\n  }\n\n  /* Returns the ring that encloses this one, if any */\n  _calcEnclosingRing () {\n    // start with the ealier sweep line event so that the prevSeg\n    // chain doesn't lead us inside of a loop of ours\n    let leftMostEvt = this.events[0]\n    for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n      const evt = this.events[i]\n      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt\n    }\n\n    let prevSeg = leftMostEvt.segment.prevInResult()\n    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null\n\n    while (true) {\n      // no segment found, thus no ring can enclose us\n      if (!prevSeg) return null\n\n      // no segments below prev segment found, thus the ring of the prev\n      // segment must loop back around and enclose us\n      if (!prevPrevSeg) return prevSeg.ringOut\n\n      // if the two segments are of different rings, the ring of the prev\n      // segment must either loop around us or the ring of the prev prev\n      // seg, which would make us and the ring of the prev peers\n      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n          return prevSeg.ringOut\n        } else return prevSeg.ringOut.enclosingRing()\n      }\n\n      // two segments are from the same ring, so this was a penisula\n      // of that ring. iterate downward, keep searching\n      prevSeg = prevPrevSeg.prevInResult()\n      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null\n    }\n  }\n}\n\nexport class PolyOut {\n  constructor (exteriorRing) {\n    this.exteriorRing = exteriorRing\n    exteriorRing.poly = this\n    this.interiorRings = []\n  }\n\n  addInterior (ring) {\n    this.interiorRings.push(ring)\n    ring.poly = this\n  }\n\n  getGeom () {\n    const geom = [this.exteriorRing.getGeom()]\n    // exterior ring was all (within rounding error of angle calc) colinear points\n    if (geom[0] === null) return null\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringGeom = this.interiorRings[i].getGeom()\n      // interior ring was all (within rounding error of angle calc) colinear points\n      if (ringGeom === null) continue\n      geom.push(ringGeom)\n    }\n    return geom\n  }\n}\n\nexport class MultiPolyOut {\n  constructor (rings) {\n    this.rings = rings\n    this.polys = this._composePolys(rings)\n  }\n\n  getGeom () {\n    const geom = []\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polyGeom = this.polys[i].getGeom()\n      // exterior ring was all (within rounding error of angle calc) colinear points\n      if (polyGeom === null) continue\n      geom.push(polyGeom)\n    }\n    return geom\n  }\n\n  _composePolys (rings) {\n    const polys = []\n    for (let i = 0, iMax = rings.length; i < iMax; i++) {\n      const ring = rings[i]\n      if (ring.poly) continue\n      if (ring.isExteriorRing()) polys.push(new PolyOut(ring))\n      else {\n        const enclosingRing = ring.enclosingRing()\n        if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing))\n        enclosingRing.poly.addInterior(ring)\n      }\n    }\n    return polys\n  }\n}\n","import SplayTree from 'splaytree'\nimport Segment from './segment'\nimport SweepEvent from './sweep-event'\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nexport default class SweepLine {\n  constructor (queue, comparator = Segment.compare) {\n    this.queue = queue\n    this.tree = new SplayTree(comparator)\n    this.segments = []\n  }\n\n  process (event) {\n    const segment = event.segment\n    const newEvents = []\n\n    // if we've already been consumed by another segment,\n    // clean up our body parts and get out\n    if (event.consumedBy) {\n      if (event.isLeft) this.queue.remove(event.otherSE)\n      else this.tree.remove(segment)\n      return newEvents\n    }\n\n    const node = event.isLeft\n      ? this.tree.insert(segment)\n      : this.tree.find(segment)\n\n    if (! node) throw new Error(\n      `Unable to find segment #${segment.id} ` +\n      `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` +\n      `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` +\n      'in SweepLine tree. Please submit a bug report.'\n    )\n\n    let prevNode = node\n    let nextNode = node\n    let prevSeg = undefined\n    let nextSeg = undefined\n\n    // skip consumed segments still in tree\n    while (prevSeg === undefined) {\n      prevNode = this.tree.prev(prevNode)\n      if (prevNode === null) prevSeg = null\n      else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key\n    }\n\n    // skip consumed segments still in tree\n    while (nextSeg === undefined) {\n      nextNode = this.tree.next(nextNode)\n      if (nextNode === null) nextSeg = null\n      else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key\n    }\n\n    if (event.isLeft) {\n\n      // Check for intersections against the previous segment in the sweep line\n      let prevMySplitter = null\n      if (prevSeg) {\n        const prevInter = prevSeg.getIntersection(segment)\n        if (prevInter !== null) {\n          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter\n          if (!prevSeg.isAnEndpoint(prevInter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      // Check for intersections against the next segment in the sweep line\n      let nextMySplitter = null\n      if (nextSeg) {\n        const nextInter = nextSeg.getIntersection(segment)\n        if (nextInter !== null) {\n          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter\n          if (!nextSeg.isAnEndpoint(nextInter))  {\n            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      // For simplicity, even if we find more than one intersection we only\n      // spilt on the 'earliest' (sweep-line style) of the intersections.\n      // The other intersection will be handled in a future process().\n      if (prevMySplitter !== null || nextMySplitter !== null) {\n\n        let mySplitter = null\n        if (prevMySplitter === null) mySplitter = nextMySplitter\n        else if (nextMySplitter === null) mySplitter = prevMySplitter\n        else {\n          const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter)\n          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter\n        }\n\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        this.queue.remove(segment.rightSE)\n        newEvents.push(segment.rightSE)\n\n        const newEventsFromSplit = segment.split(mySplitter)\n        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n          newEvents.push(newEventsFromSplit[i])\n        }\n      }\n\n      if (newEvents.length > 0) {\n        // We found some intersections, so re-do the current event to\n        // make sure sweep line ordering is totally consistent for later\n        // use with the segment 'prev' pointers\n        this.tree.remove(segment)\n        newEvents.push(event)\n\n      } else {\n        // done with left event\n        this.segments.push(segment)\n        segment.prev = prevSeg\n      }\n\n    } else {\n      // event.isRight\n\n      // since we're about to be removed from the sweep line, check for\n      // intersections between our previous and next segments\n      if (prevSeg && nextSeg) {\n        const inter = prevSeg.getIntersection(nextSeg)\n        if (inter !== null) {\n          if (!prevSeg.isAnEndpoint(inter))  {\n            const newEventsFromSplit = this._splitSafely(prevSeg, inter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n          if (!nextSeg.isAnEndpoint(inter))  {\n            const newEventsFromSplit = this._splitSafely(nextSeg, inter)\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i])\n            }\n          }\n        }\n      }\n\n      this.tree.remove(segment)\n    }\n\n    return newEvents\n  }\n\n  /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */\n  _splitSafely(seg, pt) {\n    // Rounding errors can cause changes in ordering,\n    // so remove afected segments and right sweep events before splitting\n    // removeNode() doesn't work, so have re-find the seg\n    // https://github.com/w8r/splay-tree/pull/5\n    this.tree.remove(seg)\n    const rightSE = seg.rightSE\n    this.queue.remove(rightSE)\n    const newEvents = seg.split(pt)\n    newEvents.push(rightSE)\n    // splitting can trigger consumption\n    if (seg.consumedBy === undefined) this.tree.insert(seg)\n    return newEvents\n  }\n}\n","import SplayTree from 'splaytree'\nimport { getBboxOverlap } from './bbox'\nimport * as geomIn from './geom-in'\nimport * as geomOut from './geom-out'\nimport rounder from './rounder'\nimport SweepEvent from './sweep-event'\nimport SweepLine from './sweep-line'\n\nexport class Operation {\n  run (type, geom, moreGeoms) {\n    operation.type = type\n    rounder.reset()\n\n    /* Convert inputs to MultiPoly objects */\n    const multipolys = [new geomIn.MultiPolyIn(geom, true)]\n    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n      multipolys.push(new geomIn.MultiPolyIn(moreGeoms[i], false))\n    }\n    operation.numMultiPolys = multipolys.length\n\n    /* BBox optimization for difference operation\n     * If the bbox of a multipolygon that's part of the clipping doesn't\n     * intersect the bbox of the subject at all, we can just drop that\n     * multiploygon. */\n    if (operation.type === 'difference') {\n      // in place removal\n      const subject = multipolys[0]\n      let i = 1\n      while (i < multipolys.length) {\n        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++\n        else multipolys.splice(i, 1)\n      }\n    }\n\n    /* BBox optimization for intersection operation\n     * If we can find any pair of multipolygons whose bbox does not overlap,\n     * then the result will be empty. */\n    if (operation.type === 'intersection') {\n      // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n      //       it could be optimized to O(n * ln(n))\n      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n        const mpA = multipolys[i]\n        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return []\n        }\n      }\n    }\n\n    /* Put segment endpoints in a priority queue */\n    const queue = new SplayTree(SweepEvent.compare)\n    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n      const sweepEvents = multipolys[i].getSweepEvents()\n      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n        queue.insert(sweepEvents[j])\n      }\n    }\n\n    /* Pass the sweep line over those endpoints */\n    const sweepLine = new SweepLine(queue)\n    let prevQueueSize = queue.size\n    let node = queue.pop()\n    while (node) {\n      const evt = node.key\n      if (queue.size === prevQueueSize) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        const seg = evt.segment\n        throw new Error(\n          `Unable to pop() ${evt.isLeft ? 'left' : 'right'} SweepEvent ` +\n          `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` +\n          `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` +\n          `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue. ` +\n          'Please file a bug report.'\n        )\n      }\n      const newEvents = sweepLine.process(evt)\n      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n        const evt = newEvents[i]\n        if (evt.consumedBy === undefined) queue.insert(evt)\n      }\n      prevQueueSize = queue.size\n      node = queue.pop()\n    }\n\n    // free some memory we don't need anymore\n    rounder.reset()\n\n    /* Collect and compile segments we're keeping into a multipolygon */\n    const ringsOut = geomOut.RingOut.factory(sweepLine.segments)\n    const result = new geomOut.MultiPolyOut(ringsOut)\n    return result.getGeom()\n  }\n}\n\n// singleton available by import\nconst operation = new Operation()\n\nexport default operation\n","import operation from './operation'\n\nconst union = (geom, ...moreGeoms) =>\n  operation.run('union', geom, moreGeoms)\n\nconst intersection = (geom, ...moreGeoms) =>\n  operation.run('intersection', geom, moreGeoms)\n\nconst xor = (geom, ...moreGeoms) =>\n  operation.run('xor', geom, moreGeoms)\n\nconst difference = (subjectGeom, ...clippingGeoms) =>\n  operation.run('difference', subjectGeom, clippingGeoms)\n\nexport default {\n  union: union,\n  intersection: intersection,\n  xor: xor,\n  difference: difference,\n}\n"],"names":["Node","key","data","next","left","right","DEFAULT_COMPARE","a","b","splay","i","t","comparator","N","l","r","cmp","y","insert","node","split","v","Tree","_root","_size","_comparator","this","_remove","x","current","compare","visitor","ctx","Q","done","push","length","pop","call","low","high","fn","keys","forEach","values","minNode","maxNode","index","d","root","successor","predecessor","head","p","toList","presort","size","sort","pivot","j","tmp","loadRecursive","start","end","middle","Math","floor","mergedList","l1","l2","p1","p2","mergeLists","createList","sortedListToBST","list","printNode","n","String","out","printRow","prefix","isTail","indent","join","newKey","newData","merge","isInBbox","bbox","point","ll","ur","getBboxOverlap","b1","b2","lowerX","upperX","epsilon","Number","EPSILON","undefined","pow","EPSILON_SQ","ab","PtRounder","reset","xRounder","CoordRounder","yRounder","round","tree","SplayTree","coord","add","prevNode","prev","remove","nextNode","rounder","crossProduct","dotProduct","compareVectorAngles","basePt","endPt1","endPt2","v1","v2","kross","sqrt","cosineOfAngle","pShared","pBase","pAngle","vBase","vAngle","horizontalIntersection","pt","verticalIntersection","SweepEvent","isLeft","events","ptCmp","comparePoints","link","Segment","segment","aPt","bPt","other","Error","otherEvents","iMax","evt","checkForConsuming","numEvents","evt1","consumedBy","evt2","otherSE","consume","ringOut","isInResult","baseEvent","cache","Map","fillCache","linkedEvent","nextEvent","set","sine","_this","cosine","has","get","asine","acosine","bsine","bcosine","segmentId","leftSE","rightSE","rings","windings","id","alx","blx","arx","brx","aly","bly","ary","bry","aCmpBLeft","comparePoint","bCmpARight","bCmpALeft","aCmpBRight","ay","ax","by","bx","newRightSE","y1","y2","isAnEndpoint","lPt","rPt","vector","yDist","xFromYDist","xDist","yFromXDist","tBbox","oBbox","bboxOverlap","tlp","trp","olp","orp","touchesOtherLSE","touchesThisLSE","touchesOtherRSE","touchesThisRSE","pt1","pt2","ve","d1","d2","intersection","newEvents","alreadyLinked","newLeftSE","oldRightSE","replaceRightSE","newSeg","slice","swapEvents","tmpEvt","consumer","consumee","ring","winding","indexOf","_prevInResult","prevInResult","_beforeState","seg","afterState","multiPolys","_afterState","beforeState","ringsAfter","windingsAfter","mpsAfter","polysAfter","polysExclude","poly","isExterior","splice","mp","multiPoly","_isInResult","mpsBefore","operation","type","noBefores","noAfters","least","most","numMultiPolys","diff","abs","isJustSubject","mps","isSubject","leftPt","rightPt","cmpPts","RingIn","geomRing","Array","isArray","segments","firstPoint","prevPoint","fromRing","sweepEvents","PolyIn","geomPoly","exteriorRing","interiorRings","getSweepEvents","ringSweepEvents","jMax","MultiPolyIn","geom","ex","polys","POSITIVE_INFINITY","NEGATIVE_INFINITY","polySweepEvents","RingOut","allSegments","ringsOut","prevEvent","event","startingPoint","intersectionLEs","availableLEs","getAvailableLinkedEvents","firstPt","lastPt","indexLE","getLeftmostComparator","intersectionLE","ringEvents","unshift","reverse","prevPt","points","nextPt","shift","step","isExteriorRing","iStart","iEnd","orderedPoints","_isExteriorRing","enclosing","enclosingRing","_enclosingRing","_calcEnclosingRing","leftMostEvt","prevSeg","prevPrevSeg","PolyOut","getGeom","ringGeom","MultiPolyOut","_composePolys","polyGeom","addInterior","SweepLine","queue","find","nextSeg","prevMySplitter","prevInter","getIntersection","newEventsFromSplit","_splitSafely","nextMySplitter","nextInter","mySplitter","inter","moreGeoms","multipolys","geomIn","subject","mpA","sweepLine","prevQueueSize","process","geomOut","factory","union","run","xor","difference","subjectGeom","clippingGeoms"],"mappings":"sgBASMA,EACF,WAAYC,EAAKC,kBACRC,KAAO,UACPF,IAAMA,OACNC,KAAOA,OACPE,KAAO,UACPC,MAAQ,MAOrB,SAASC,EAAgBC,EAAGC,UACjBD,EAAIC,EAAI,EAAID,EAAIC,GAAK,EAAI,EAKpC,SAASC,EAAMC,EAAGC,EAAGC,WACXC,EAAI,IAAIb,EAAK,KAAM,MACrBc,EAAID,EACJE,EAAIF,IACK,KACHG,EAAMJ,EAAWF,EAAGC,EAAEV,QAExBe,EAAM,EAAG,IACM,OAAXL,EAAEP,KACF,SAEAQ,EAAWF,EAAGC,EAAEP,KAAKH,KAAO,EAAG,KACzBgB,EAAIN,EAAEP,QACZO,EAAEP,KAAOa,EAAEZ,MACXY,EAAEZ,MAAQM,EAEK,QADfA,EAAIM,GACEb,KACF,MAERW,EAAEX,KAAOO,EACTI,EAAIJ,EACJA,EAAIA,EAAEP,SAGL,CAAA,KAAIY,EAAM,GAiBX,SAhBgB,OAAZL,EAAEN,MACF,SAEAO,EAAWF,EAAGC,EAAEN,MAAMJ,KAAO,EAAG,KAC1BgB,EAAIN,EAAEN,SACZM,EAAEN,MAAQY,EAAEb,KACZa,EAAEb,KAAOO,EAEO,QADhBA,EAAIM,GACEZ,MACF,MAERS,EAAET,MAAQM,EACVG,EAAIH,EACJA,EAAIA,EAAEN,cAMdS,EAAET,MAAQM,EAAEP,KACZW,EAAEX,KAAOO,EAAEN,MACXM,EAAEP,KAAOS,EAAER,MACXM,EAAEN,MAAQQ,EAAET,KACLO,EAEX,SAASO,EAAOR,EAAGR,EAAMS,EAAGC,OAClBO,EAAO,IAAInB,EAAKU,EAAGR,MACf,OAANS,SACAQ,EAAKf,KAAOe,EAAKd,MAAQ,KAClBc,MAGLH,EAAMJ,EAAWF,GADvBC,EAAIF,EAAMC,EAAGC,EAAGC,IACYX,YACxBe,EAAM,GACNG,EAAKf,KAAOO,EAAEP,KACde,EAAKd,MAAQM,EACbA,EAAEP,KAAO,MAEJY,GAAO,IACZG,EAAKd,MAAQM,EAAEN,MACfc,EAAKf,KAAOO,EACZA,EAAEN,MAAQ,MAEPc,EAEX,SAASC,EAAMnB,EAAKoB,EAAGT,OACfR,EAAO,KACPC,EAAQ,QACRgB,EAAG,KAEGL,EAAMJ,GADZS,EAAIZ,EAAMR,EAAKoB,EAAGT,IACOX,IAAKA,GAClB,IAARe,GACAZ,EAAOiB,EAAEjB,KACTC,EAAQgB,EAAEhB,OAELW,EAAM,GACXX,EAAQgB,EAAEhB,MACVgB,EAAEhB,MAAQ,KACVD,EAAOiB,IAGPjB,EAAOiB,EAAEjB,KACTiB,EAAEjB,KAAO,KACTC,EAAQgB,SAGT,CAAEjB,KAAAA,EAAMC,MAAAA,OAwBbiB,8BACUV,yDAAaN,iBAChBiB,MAAQ,UACRC,MAAQ,OACRC,YAAcb,2CAKhBX,EAAKC,eACHsB,QACEE,KAAKH,MAAQL,EAAOjB,EAAKC,EAAMwB,KAAKH,MAAOG,KAAKD,yCAKvDxB,EAAKC,OACCiB,EAAO,IAAInB,EAAKC,EAAKC,GACR,OAAfwB,KAAKH,QACLJ,EAAKf,KAAOe,EAAKd,MAAQ,UACpBmB,aACAD,MAAQJ,OAEXP,EAAac,KAAKD,YAClBd,EAAIF,EAAMR,EAAKyB,KAAKH,MAAOX,GAC3BI,EAAMJ,EAAWX,EAAKU,EAAEV,YAClB,IAARe,EACAU,KAAKH,MAAQZ,GAETK,EAAM,GACNG,EAAKf,KAAOO,EAAEP,KACde,EAAKd,MAAQM,EACbA,EAAEP,KAAO,MAEJY,EAAM,IACXG,EAAKd,MAAQM,EAAEN,MACfc,EAAKf,KAAOO,EACZA,EAAEN,MAAQ,WAETmB,aACAD,MAAQJ,GAEVO,KAAKH,qCAMTtB,QACEsB,MAAQG,KAAKC,QAAQ1B,EAAKyB,KAAKH,MAAOG,KAAKD,6CAK5Cf,EAAGC,EAAGC,OACNgB,SACM,OAANjB,EACO,KAGC,IADAC,EAAWF,GADvBC,EAAIF,EAAMC,EAAGC,EAAGC,IACYX,MAET,OAAXU,EAAEP,KACFwB,EAAIjB,EAAEN,OAGNuB,EAAInB,EAAMC,EAAGC,EAAEP,KAAMQ,IACnBP,MAAQM,EAAEN,WAEXmB,QACEI,GAEJjB,oCAMHQ,EAAOO,KAAKH,SACZJ,EAAM,MACCA,EAAKf,MACRe,EAAOA,EAAKf,iBACXmB,MAAQd,EAAMU,EAAKlB,IAAKyB,KAAKH,MAAOG,KAAKD,kBACzCF,MAAQG,KAAKC,QAAQR,EAAKlB,IAAKyB,KAAKH,MAAOG,KAAKD,aAC9C,CAAExB,IAAKkB,EAAKlB,IAAKC,KAAMiB,EAAKjB,aAEhC,wCAKAD,WACH4B,EAAUH,KAAKH,MACbO,EAAUJ,KAAKD,YACdI,GAAS,KACNb,EAAMc,EAAQ7B,EAAK4B,EAAQ5B,QACrB,IAARe,EACA,OAAOa,EAEPA,EADKb,EAAM,EACDa,EAAQzB,KAERyB,EAAQxB,aAEnB,kCAENJ,UACGyB,KAAKH,aACAA,MAAQd,EAAMR,EAAKyB,KAAKH,MAAOG,KAAKD,aACK,IAA1CC,KAAKD,YAAYxB,EAAKyB,KAAKH,MAAMtB,MAC1B,KAERyB,KAAKH,uCAEPtB,WACD4B,EAAUH,KAAKH,MACbO,EAAUJ,KAAKD,YACdI,GAAS,KACNb,EAAMc,EAAQ7B,EAAK4B,EAAQ5B,QACrB,IAARe,EACA,OAAO,EAEPa,EADKb,EAAM,EACDa,EAAQzB,KAERyB,EAAQxB,aAEnB,kCAEH0B,EAASC,WACTH,EAAUH,KAAKH,MACbU,EAAI,GACNC,GAAO,GACHA,GACY,OAAZL,GACAI,EAAEE,KAAKN,GACPA,EAAUA,EAAQzB,MAGD,IAAb6B,EAAEG,QACFP,EAAUI,EAAEI,MACZN,EAAQO,KAAKN,EAAKH,GAClBA,EAAUA,EAAQxB,OAGlB6B,GAAO,SAGZR,mCAKLa,EAAKC,EAAMC,EAAIT,WACXC,EAAI,GACJH,EAAUJ,KAAKD,YACjBN,EAAOO,KAAKH,MAEI,IAAbU,EAAEG,QAAgBjB,MACjBA,EACAc,EAAEE,KAAKhB,GACPA,EAAOA,EAAKf,SAEX,IAEK0B,GADNX,EAAOc,EAAEI,OACUpC,IAAKuC,GACd,QAGL,GAAIV,EAAQX,EAAKlB,IAAKsC,IAAQ,GAC3BE,EAAGH,KAAKN,EAAKb,GACb,OAAOO,KAEfP,EAAOA,EAAKd,aAGbqB,wCAMDgB,EAAO,eACRC,QAAQ,gBAAG1C,IAAAA,WAAUyC,EAAKP,KAAKlC,KAC7ByC,uCAMDE,EAAS,eACVD,QAAQ,gBAAGzC,IAAAA,YAAW0C,EAAOT,KAAKjC,KAChC0C,uCAGHlB,KAAKH,MACEG,KAAKmB,QAAQnB,KAAKH,OAAOtB,IAC7B,0CAGHyB,KAAKH,MACEG,KAAKoB,QAAQpB,KAAKH,OAAOtB,IAC7B,2CAEHU,yDAAIe,KAAKH,SACTZ,EACA,KAAOA,EAAEP,MACLO,EAAIA,EAAEP,YACPO,wCAEHA,yDAAIe,KAAKH,SACTZ,EACA,KAAOA,EAAEN,OACLM,EAAIA,EAAEN,aACPM,6BAKRoC,WACKlB,EAAUH,KAAKH,MACfW,GAAO,EACPxB,EAAI,EACFuB,EAAI,IACFC,MACAL,EACAI,EAAEE,KAAKN,GACPA,EAAUA,EAAQzB,aAGd6B,EAAEG,OAAS,EAAG,IACdP,EAAUI,EAAEI,MACR3B,IAAMqC,EACN,OAAOlB,EACXnB,IACAmB,EAAUA,EAAQxB,WAGlB6B,GAAO,SAGZ,kCAENc,OACGC,EAAOvB,KAAKH,MACZ2B,EAAY,QACZF,EAAE3C,MAAO,KACT6C,EAAYF,EAAE3C,MACP6C,EAAU9C,MACb8C,EAAYA,EAAU9C,YACnB8C,UAELtC,EAAac,KAAKD,YACjBwB,GAAM,KACHjC,EAAMJ,EAAWoC,EAAE/C,IAAKgD,EAAKhD,QACvB,IAARe,EACA,MACKA,EAAM,GACXkC,EAAYD,EACZA,EAAOA,EAAK7C,MAGZ6C,EAAOA,EAAK5C,aAEb6C,+BAENF,OACGC,EAAOvB,KAAKH,MACZ4B,EAAc,QACH,OAAXH,EAAE5C,KAAe,KACjB+C,EAAcH,EAAE5C,KACT+C,EAAY9C,OACf8C,EAAcA,EAAY9C,aACvB8C,UAELvC,EAAac,KAAKD,YACjBwB,GAAM,KACHjC,EAAMJ,EAAWoC,EAAE/C,IAAKgD,EAAKhD,QACvB,IAARe,EACA,MACKA,EAAM,EACXiC,EAAOA,EAAK7C,MAEZ+C,EAAcF,EACdA,EAAOA,EAAK5C,cAGb8C,8CAGF5B,MAAQ,UACRC,MAAQ,EACNE,6CAsEf,SAAgBuB,OACRpB,EAAUoB,EACRhB,EAAI,GACNC,GAAO,EACLkB,EAAO,IAAIpD,EAAK,KAAM,MACxBqD,EAAID,QACAlB,GACAL,GACAI,EAAEE,KAAKN,GACPA,EAAUA,EAAQzB,MAGd6B,EAAEG,OAAS,EAEXP,GADAA,EAAUwB,EAAIA,EAAElD,KAAO8B,EAAEI,OACPhC,MAGlB6B,GAAO,SAGnBmB,EAAElD,KAAO,KACFiD,EAAKjD,KAxFDmD,CAAO5B,KAAKH,oCAKlBmB,OAAME,yDAAS,GAAIW,0DAChBC,EAAOd,EAAKN,OACVxB,EAAac,KAAKD,eAEpB8B,GAsHZ,SAASE,EAAKf,EAAME,EAAQxC,EAAMC,EAAOyB,MACjC1B,GAAQC,EACR,WACEqD,EAAQhB,EAAMtC,EAAOC,GAAU,OACjCK,EAAIN,EAAO,MACXuD,EAAItD,EAAQ,SACH,IAELK,UACGoB,EAAQY,EAAKhC,GAAIgD,GAAS,MAE7BC,UACG7B,EAAQY,EAAKiB,GAAID,GAAS,MAC7BhD,GAAKiD,EACL,UACAC,EAAMlB,EAAKhC,GACfgC,EAAKhC,GAAKgC,EAAKiB,GACfjB,EAAKiB,GAAKC,EACVA,EAAMhB,EAAOlC,GACbkC,EAAOlC,GAAKkC,EAAOe,GACnBf,EAAOe,GAAKC,EAEhBH,EAAKf,EAAME,EAAQxC,EAAMuD,EAAG7B,GAC5B2B,EAAKf,EAAME,EAAQe,EAAI,EAAGtD,EAAOyB,GA5IzB2B,CAAKf,EAAME,EAAQ,EAAGY,EAAO,EAAG5C,GACjB,OAAfc,KAAKH,WACAA,MAiCjB,SAASsC,EAAcnB,EAAME,EAAQkB,EAAOC,OAClCP,EAAOO,EAAMD,KACfN,EAAO,EAAG,KACJQ,EAASF,EAAQG,KAAKC,MAAMV,EAAO,GACnCvD,EAAMyC,EAAKsB,GACX9D,EAAO0C,EAAOoB,GACd7C,EAAO,IAAInB,EAAKC,EAAKC,UAC3BiB,EAAKf,KAAOyD,EAAcnB,EAAME,EAAQkB,EAAOE,GAC/C7C,EAAKd,MAAQwD,EAAcnB,EAAME,EAAQoB,EAAS,EAAGD,GAC9C5C,SAEJ,KA5Cc0C,CAAcnB,EAAME,EAAQ,EAAGY,QACvChC,MAAQgC,MAEZ,KACKW,EAuFlB,SAAoBC,EAAIC,EAAIvC,OAClBsB,EAAO,IAAIpD,EAAK,KAAM,MACxBqD,EAAID,EACJkB,EAAKF,EACLG,EAAKF,OACK,OAAPC,GAAsB,OAAPC,GACdzC,EAAQwC,EAAGrE,IAAKsE,EAAGtE,KAAO,GAC1BoD,EAAElD,KAAOmE,EACTA,EAAKA,EAAGnE,OAGRkD,EAAElD,KAAOoE,EACTA,EAAKA,EAAGpE,MAEZkD,EAAIA,EAAElD,KAEC,OAAPmE,EACAjB,EAAElD,KAAOmE,EAEG,OAAPC,IACLlB,EAAElD,KAAOoE,UAENnB,EAAKjD,KA7GeqE,CAAW9C,KAAK4B,SA0C/C,SAAoBZ,EAAME,WAChBQ,EAAO,IAAIpD,EAAK,KAAM,MACxBqD,EAAID,EACC1C,EAAI,EAAGA,EAAIgC,EAAKN,OAAQ1B,IAC7B2C,EAAIA,EAAElD,KAAO,IAAIH,EAAK0C,EAAKhC,GAAIkC,EAAOlC,WAE1C2C,EAAElD,KAAO,KACFiD,EAAKjD,KAjDyCsE,CAAW/B,EAAME,GAAShC,GACvE4C,EAAO9B,KAAKF,MAAQgC,OACfjC,MAwEjB,SAASmD,EAAgBC,EAAMb,EAAOC,OAC5BP,EAAOO,EAAMD,KACfN,EAAO,EAAG,KACJQ,EAASF,EAAQG,KAAKC,MAAMV,EAAO,GACnCpD,EAAOsE,EAAgBC,EAAMb,EAAOE,GACpCf,EAAO0B,EAAKvB,YAClBH,EAAK7C,KAAOA,EACZuE,EAAKvB,KAAOuB,EAAKvB,KAAKjD,KACtB8C,EAAK5C,MAAQqE,EAAgBC,EAAMX,EAAS,EAAGD,GACxCd,SAEJ,KAnFcyB,CAAgB,CAAEtB,KAAMe,GAAc,EAAGX,UAEnD9B,8CAEuB,OAAfA,KAAKH,6CAGfqD,yDAAY,SAACC,UAAMC,OAAOD,EAAE5E,MAC3B8E,EAAM,UAxUpB,SAASC,EAAS/B,EAAMgC,EAAQC,EAAQH,EAAKH,MACrC3B,EAAM,CACN8B,YAAOE,UAASC,EAAS,OAAS,eAASN,EAAU3B,cAC/CkC,EAASF,GAAUC,EAAS,OAAS,QACvCjC,EAAK7C,MACL4E,EAAS/B,EAAK7C,KAAM+E,GAAQ,EAAOJ,EAAKH,GACxC3B,EAAK5C,OACL2E,EAAS/B,EAAK5C,MAAO8E,GAAQ,EAAMJ,EAAKH,IAkU5CI,CAAStD,KAAKH,MAAO,IAAI,EAAM,SAACF,UAAM0D,EAAI5C,KAAKd,IAAIuD,GAC5CG,EAAIK,KAAK,mCAEbnF,EAAKoF,EAAQC,OACV1E,EAAac,KAAKD,cACFL,EAAMnB,EAAKyB,KAAKH,MAAOX,GAAvCR,IAAAA,KAAMC,IAAAA,MACRO,EAAWX,EAAKoF,GAAU,EAC1BhF,EAAQa,EAAOmE,EAAQC,EAASjF,EAAOO,GAGvCR,EAAOc,EAAOmE,EAAQC,EAASlF,EAAMQ,QAEpCW,MAjWb,SAAenB,EAAMC,EAAOO,UACV,OAAVP,EACOD,EACE,OAATA,EACOC,IACXA,EAAQI,EAAML,EAAKH,IAAKI,EAAOO,IACzBR,KAAOA,EACNC,GA0VUkF,CAAMnF,EAAMC,EAAOO,iCAE9BX,UACKmB,EAAMnB,EAAKyB,KAAKH,MAAOG,KAAKD,iDAnBnBC,KAAKF,0CACLE,KAAKH,eCpctB,IAAMiE,EAAW,SAACC,EAAMC,UAE1BD,EAAKE,GAAG/D,GAAK8D,EAAM9D,GACnB8D,EAAM9D,GAAK6D,EAAKG,GAAGhE,GACnB6D,EAAKE,GAAG1E,GAAKyE,EAAMzE,GACnByE,EAAMzE,GAAKwE,EAAKG,GAAG3E,GAOX4E,EAAiB,SAACC,EAAIC,MAG/BA,EAAGH,GAAGhE,EAAIkE,EAAGH,GAAG/D,GAChBkE,EAAGF,GAAGhE,EAAImE,EAAGJ,GAAG/D,GAChBmE,EAAGH,GAAG3E,EAAI6E,EAAGH,GAAG1E,GAChB6E,EAAGF,GAAG3E,EAAI8E,EAAGJ,GAAG1E,EAChB,OAAO,SAGH+E,EAASF,EAAGH,GAAG/D,EAAImE,EAAGJ,GAAG/D,EAAImE,EAAGJ,GAAG/D,EAAIkE,EAAGH,GAAG/D,EAC7CqE,EAASH,EAAGF,GAAGhE,EAAImE,EAAGH,GAAGhE,EAAIkE,EAAGF,GAAGhE,EAAImE,EAAGH,GAAGhE,QAO5C,CAAE+D,GAAI,CAAE/D,EAAGoE,EAAQ/E,EAJX6E,EAAGH,GAAG1E,EAAI8E,EAAGJ,GAAG1E,EAAI8E,EAAGJ,GAAG1E,EAAI6E,EAAGH,GAAG1E,GAIZ2E,GAAI,CAAEhE,EAAGqE,EAAQhF,EAHzC6E,EAAGF,GAAG3E,EAAI8E,EAAGH,GAAG3E,EAAI6E,EAAGF,GAAG3E,EAAI8E,EAAGH,GAAG3E,KC5BjDiF,EAAUC,OAAOC,aAGLC,IAAZH,IAAuBA,EAAUjC,KAAKqC,IAAI,GAAI,KAElD,IAAMC,EAAaL,EAAUA,EAGhBlF,EAAM,SAACT,EAAGC,OAEhB0F,EAAU3F,GAAKA,EAAI2F,IACjBA,EAAU1F,GAAKA,EAAI0F,SACf,MAKLM,EAAKjG,EAAIC,SACXgG,EAAKA,EAAKD,EAAahG,EAAIC,EACtB,EAIFD,EAAIC,GAAK,EAAI,GCbhBiG,yCAEGC,uDAIAC,SAAW,IAAIC,OACfC,SAAW,IAAID,gCAGfhF,EAAGX,SACD,CACLW,EAAGF,KAAKiF,SAASG,MAAMlF,GACvBX,EAAGS,KAAKmF,SAASC,MAAM7F,aAKvB2F,yCAEGG,KAAO,IAAIC,OAEXF,MAAM,2CAUNG,OACC9F,EAAOO,KAAKqF,KAAKG,IAAID,GAErBE,EAAWzF,KAAKqF,KAAKK,KAAKjG,MACf,OAAbgG,GAAqD,IAAhCnG,EAAIG,EAAKlB,IAAKkH,EAASlH,iBACzC8G,KAAKM,OAAOJ,GACVE,EAASlH,QAGZqH,EAAW5F,KAAKqF,KAAK5G,KAAKgB,UACf,OAAbmG,GAAqD,IAAhCtG,EAAIG,EAAKlB,IAAKqH,EAASrH,WACzC8G,KAAKM,OAAOJ,GACVK,EAASrH,KAGXgH,WAKLM,EAAU,IAAId,ECjEPe,EAAe,SAACjH,EAAGC,UAAMD,EAAEqB,EAAIpB,EAAES,EAAIV,EAAEU,EAAIT,EAAEoB,GAG7C6F,EAAa,SAAClH,EAAGC,UAAMD,EAAEqB,EAAIpB,EAAEoB,EAAIrB,EAAEU,EAAIT,EAAES,GAG3CyG,EAAsB,SAACC,EAAQC,EAAQC,OAC5CC,EAAK,CAAElG,EAAGgG,EAAOhG,EAAI+F,EAAO/F,EAAGX,EAAG2G,EAAO3G,EAAI0G,EAAO1G,GACpD8G,EAAK,CAAEnG,EAAGiG,EAAOjG,EAAI+F,EAAO/F,EAAGX,EAAG4G,EAAO5G,EAAI0G,EAAO1G,GACpD+G,EAAQR,EAAaM,EAAIC,UACxB/G,EAAIgH,EAAO,IAGP5F,EAAS,SAAAf,UAAK4C,KAAKgE,KAAKR,EAAWpG,EAAGA,KAUtC6G,EAAgB,SAACC,EAASC,EAAOC,OACtCC,EAAQ,CAAE1G,EAAGwG,EAAMxG,EAAIuG,EAAQvG,EAAGX,EAAGmH,EAAMnH,EAAIkH,EAAQlH,GACvDsH,EAAS,CAAE3G,EAAGyG,EAAOzG,EAAIuG,EAAQvG,EAAGX,EAAGoH,EAAOpH,EAAIkH,EAAQlH,UACzDwG,EAAWc,EAAQD,GAASlG,EAAOmG,GAAUnG,EAAOkG,IA2ChDE,EAAyB,SAACC,EAAIpH,EAAGJ,UAChC,IAARI,EAAEJ,EAAgB,KACf,CAAEW,EAAG6G,EAAG7G,EAAIP,EAAEO,EAAIP,EAAEJ,GAAMA,EAAIwH,EAAGxH,GAAKA,EAAGA,IAMrCyH,EAAuB,SAACD,EAAIpH,EAAGO,UAC9B,IAARP,EAAEO,EAAgB,KACf,CAAEA,EAAGA,EAAGX,EAAGwH,EAAGxH,EAAII,EAAEJ,EAAII,EAAEO,GAAMA,EAAI6G,EAAG7G,KC/E3B+G,wBAgCNjD,EAAOkD,kBACGvC,IAAjBX,EAAMmD,OAAsBnD,EAAMmD,OAAS,CAACnH,MAC3CgE,EAAMmD,OAAO1G,KAAKT,WAClBgE,MAAQA,OACRkD,OAASA,iDAjCArI,EAAGC,OAGXsI,EAAQH,EAAWI,cAAcxI,EAAEmF,MAAOlF,EAAEkF,cACpC,IAAVoD,EAAoBA,GAGpBvI,EAAEmF,QAAUlF,EAAEkF,OAAOnF,EAAEyI,KAAKxI,GAG5BD,EAAEqI,SAAWpI,EAAEoI,OAAerI,EAAEqI,OAAS,GAAK,EAI3CK,EAAQnH,QAAQvB,EAAE2I,QAAS1I,EAAE0I,gDAIhBC,EAAKC,UACrBD,EAAIvH,EAAIwH,EAAIxH,GAAW,EACvBuH,EAAIvH,EAAIwH,EAAIxH,EAAU,EAEtBuH,EAAIlI,EAAImI,EAAInI,GAAW,EACvBkI,EAAIlI,EAAImI,EAAInI,EAAU,EAEnB,sCAYHoI,MACAA,EAAM3D,QAAUhE,KAAKgE,YACjB,IAAI4D,MAAM,+CAEZC,EAAcF,EAAM3D,MAAMmD,OACvBnI,EAAI,EAAG8I,EAAOD,EAAYnH,OAAQ1B,EAAI8I,EAAM9I,IAAK,KAClD+I,EAAMF,EAAY7I,QACnBgF,MAAMmD,OAAO1G,KAAKsH,GACvBA,EAAI/D,MAAQhE,KAAKgE,WAEdgE,wEAYCC,EAAYjI,KAAKgE,MAAMmD,OAAOzG,OAC3B1B,EAAI,EAAGA,EAAIiJ,EAAWjJ,IAAK,KAC5BkJ,EAAOlI,KAAKgE,MAAMmD,OAAOnI,WACC2F,IAA5BuD,EAAKV,QAAQW,eACZ,IAAIlG,EAAIjD,EAAI,EAAGiD,EAAIgG,EAAWhG,IAAK,KAChCmG,EAAOpI,KAAKgE,MAAMmD,OAAOlF,QACP0C,IAApByD,EAAKD,aACLD,EAAKG,QAAQrE,MAAMmD,SAAWiB,EAAKC,QAAQrE,MAAMmD,QACrDe,EAAKV,QAAQc,QAAQF,EAAKZ,uEAOxBL,EAAS,GACNnI,EAAI,EAAG8I,EAAO9H,KAAKgE,MAAMmD,OAAOzG,OAAQ1B,EAAI8I,EAAM9I,IAAK,KACxD+I,EAAM/H,KAAKgE,MAAMmD,OAAOnI,GAC1B+I,IAAQ/H,OAAS+H,EAAIP,QAAQe,SAAWR,EAAIP,QAAQgB,cACtDrB,EAAO1G,KAAKsH,UAGTZ,gDAacsB,cACfC,EAAQ,IAAIC,IAEZC,EAAY,SAAAC,ODpFMpC,EAASC,EAAOC,EACpCC,EACAC,ECmFIiC,EAAYD,EAAYR,QAC9BK,EAAMK,IAAIF,EAAa,CACrBG,MDvFoBvC,ECuFFwC,EAAKjF,MDvFM0C,ECuFC+B,EAAUzE,MDvFJ2C,ECuFWmC,EAAU9E,MDtFzD4C,EAAQ,CAAE1G,EAAGwG,EAAMxG,EAAIuG,EAAQvG,EAAGX,EAAGmH,EAAMnH,EAAIkH,EAAQlH,GACvDsH,EAAS,CAAE3G,EAAGyG,EAAOzG,EAAIuG,EAAQvG,EAAGX,EAAGoH,EAAOpH,EAAIkH,EAAQlH,GACzDuG,EAAae,EAAQD,GAASlG,EAAOmG,GAAUnG,EAAOkG,ICqFvDsC,OAAQ1C,EAAcyC,EAAKjF,MAAOyE,EAAUzE,MAAO8E,EAAU9E,iBAI1D,SAACnF,EAAGC,GACJ4J,EAAMS,IAAItK,IAAI+J,EAAU/J,GACxB6J,EAAMS,IAAIrK,IAAI8J,EAAU9J,SAEY4J,EAAMU,IAAIvK,GAArCwK,IAANL,KAAqBM,IAARJ,SACoBR,EAAMU,IAAItK,GAArCyK,IAANP,KAAqBQ,IAARN,cAGjBG,GAAS,GAAKE,GAAS,EACrBD,EAAUE,EAAgB,EAC1BF,EAAUE,GAAiB,EACxB,EAILH,EAAQ,GAAKE,EAAQ,EACnBD,EAAUE,GAAiB,EAC3BF,EAAUE,EAAgB,EACvB,EAILD,EAAQF,GAAe,EACvBE,EAAQF,EAAc,EACnB,YC/HTI,EAAY,EAEKlC,wBA+HNmC,EAAQC,EAASC,EAAOC,kBAC9BC,KAAOL,OACPC,OAASA,EACdA,EAAOlC,QAAUxH,KACjB0J,EAAOrB,QAAUsB,OACZA,QAAUA,EACfA,EAAQnC,QAAUxH,KAClB2J,EAAQtB,QAAUqB,OACbE,MAAQA,OACRC,SAAWA,iDAzHFhL,EAAGC,OAEXiL,EAAMlL,EAAE6K,OAAO1F,MAAM9D,EACrB8J,EAAMlL,EAAE4K,OAAO1F,MAAM9D,EACrB+J,EAAMpL,EAAE8K,QAAQ3F,MAAM9D,EACtBgK,EAAMpL,EAAE6K,QAAQ3F,MAAM9D,KAGxBgK,EAAMH,EAAK,OAAO,KAClBE,EAAMD,EAAK,OAAQ,MAEjBG,EAAMtL,EAAE6K,OAAO1F,MAAMzE,EACrB6K,EAAMtL,EAAE4K,OAAO1F,MAAMzE,EACrB8K,EAAMxL,EAAE8K,QAAQ3F,MAAMzE,EACtB+K,EAAMxL,EAAE6K,QAAQ3F,MAAMzE,KAGxBwK,EAAMC,EAAK,IAETI,EAAMD,GAAOC,EAAMC,EAAK,OAAO,KAC/BD,EAAMD,GAAOC,EAAMC,EAAK,OAAQ,MAG9BE,EAAY1L,EAAE2L,aAAa1L,EAAE4K,OAAO1F,UACtCuG,EAAY,EAAG,OAAO,KACtBA,EAAY,EAAG,OAAQ,MAGrBE,EAAa3L,EAAE0L,aAAa3L,EAAE8K,QAAQ3F,cACzB,IAAfyG,EAAyBA,GAIrB,KAINV,EAAMC,EAAK,IACTG,EAAMC,GAAOD,EAAMG,EAAK,OAAQ,KAChCH,EAAMC,GAAOD,EAAMG,EAAK,OAAO,MAG7BI,EAAY5L,EAAE0L,aAAa3L,EAAE6K,OAAO1F,UACxB,IAAd0G,EAAiB,OAAOA,MAGtBC,EAAa9L,EAAE2L,aAAa1L,EAAE6K,QAAQ3F,cACxC2G,EAAa,EAAU,EACvBA,EAAa,GAAW,EAIrB,KAOLR,EAAMC,EAAK,OAAQ,KACnBD,EAAMC,EAAK,OAAO,KAMlBH,EAAMC,EAAK,KACPO,EAAa3L,EAAE0L,aAAa3L,EAAE8K,QAAQ3F,UACzB,IAAfyG,EAAkB,OAAOA,KAI3BR,EAAMC,EAAK,KACPS,EAAa9L,EAAE2L,aAAa1L,EAAE6K,QAAQ3F,UACxC2G,EAAa,EAAG,OAAO,KACvBA,EAAa,EAAG,OAAQ,KAG1BV,IAAQC,EAAM,KAGVU,EAAKP,EAAMF,EACXU,EAAKZ,EAAMF,EACXe,EAAKR,EAAMF,EACXW,EAAKb,EAAMF,KACbY,EAAKC,GAAMC,EAAKC,EAAI,OAAO,KAC3BH,EAAKC,GAAMC,EAAKC,EAAI,OAAQ,SAK9Bd,EAAMC,EAAY,EAClBD,EAAMC,GAAa,EAMnBG,EAAMC,GAAa,EACnBD,EAAMC,EAAY,EAIlBzL,EAAEiL,GAAKhL,EAAEgL,IAAY,EACrBjL,EAAEiL,GAAKhL,EAAEgL,GAAW,EAGjB,gDA4COkB,QACTrB,QAAUqB,OACVrB,QAAQnC,QAAUxH,UAClB2J,QAAQtB,QAAUrI,KAAK0J,YACvBA,OAAOrB,QAAUrI,KAAK2J,2CAIrBsB,EAAKjL,KAAK0J,OAAO1F,MAAMzE,EACvB2L,EAAKlL,KAAK2J,QAAQ3F,MAAMzE,QACvB,CACL0E,GAAI,CAAE/D,EAAGF,KAAK0J,OAAO1F,MAAM9D,EAAGX,EAAG0L,EAAKC,EAAKD,EAAKC,GAChDhH,GAAI,CAAEhE,EAAGF,KAAK2J,QAAQ3F,MAAM9D,EAAGX,EAAG0L,EAAKC,EAAKD,EAAKC,2CAM5C,CACLhL,EAAGF,KAAK2J,QAAQ3F,MAAM9D,EAAIF,KAAK0J,OAAO1F,MAAM9D,EAC5CX,EAAGS,KAAK2J,QAAQ3F,MAAMzE,EAAIS,KAAK0J,OAAO1F,MAAMzE,wCAIlCwH,UAETA,EAAG7G,IAAMF,KAAK0J,OAAO1F,MAAM9D,GAAK6G,EAAGxH,IAAMS,KAAK0J,OAAO1F,MAAMzE,GAC3DwH,EAAG7G,IAAMF,KAAK2J,QAAQ3F,MAAM9D,GAAK6G,EAAGxH,IAAMS,KAAK2J,QAAQ3F,MAAMzE,uCAiBpDyE,MACRhE,KAAKmL,aAAanH,GAAQ,OAAO,MAE/BoH,EAAMpL,KAAK0J,OAAO1F,MAClBqH,EAAMrL,KAAK2J,QAAQ3F,MACnBrE,EAAIK,KAAKsL,YAGXF,EAAIlL,IAAMmL,EAAInL,SACZ8D,EAAM9D,IAAMkL,EAAIlL,EAAU,EACvB8D,EAAM9D,EAAIkL,EAAIlL,EAAI,GAAK,MAK1BqL,GAASvH,EAAMzE,EAAI6L,EAAI7L,GAAKI,EAAEJ,EAC9BiM,EAAaJ,EAAIlL,EAAIqL,EAAQ5L,EAAEO,KACjC8D,EAAM9D,IAAMsL,EAAY,OAAO,MAI7BC,GAAUzH,EAAM9D,EAAIkL,EAAIlL,GAAKP,EAAEO,EAC/BwL,EAAaN,EAAI7L,EAAIkM,EAAQ9L,EAAEJ,SACjCyE,EAAMzE,IAAMmM,EAAmB,EAC5B1H,EAAMzE,EAAImM,GAAc,EAAI,0CAkBpB/D,OAETgE,EAAQ3L,KAAK+D,OACb6H,EAAQjE,EAAM5D,OACd8H,EAAc1H,EAAewH,EAAOC,MACtB,OAAhBC,EAAsB,OAAO,SAM3BC,EAAM9L,KAAK0J,OAAO1F,MAClB+H,EAAM/L,KAAK2J,QAAQ3F,MACnBgI,EAAMrE,EAAM+B,OAAO1F,MACnBiI,EAAMtE,EAAMgC,QAAQ3F,MAKpBkI,EAAkBpI,EAAS6H,EAAOK,IAAmC,IAA3BhM,KAAKwK,aAAawB,GAC5DG,EAAiBrI,EAAS8H,EAAOE,IAAoC,IAA5BnE,EAAM6C,aAAasB,GAC5DM,EAAkBtI,EAAS6H,EAAOM,IAAmC,IAA3BjM,KAAKwK,aAAayB,GAC5DI,EAAiBvI,EAAS8H,EAAOG,IAAoC,IAA5BpE,EAAM6C,aAAauB,MAG9DI,GAAkBD,SAGhBG,IAAmBD,EAAwBL,GAC1CM,GAAkBD,EAAwBH,EAGxC,QAILE,SAEEC,GACEN,EAAI5L,IAAM+L,EAAI/L,GAAK4L,EAAIvM,IAAM0M,EAAI1M,EAAU,KAG1CuM,KAILI,SAEEG,GACEN,EAAI7L,IAAM8L,EAAI9L,GAAK6L,EAAIxM,IAAMyM,EAAIzM,EAAU,KAG1CyM,KAILK,GAAkBD,EAAiB,OAAO,QAG1CC,EAAgB,OAAON,KACvBK,EAAiB,OAAOH,MAItBlF,EF/OkB,SAACuF,EAAKlG,EAAImG,EAAKlG,MAI5B,IAATD,EAAGlG,EAAS,OAAO8G,EAAqBuF,EAAKlG,EAAIiG,EAAIpM,MAC5C,IAATmG,EAAGnG,EAAS,OAAO8G,EAAqBsF,EAAKlG,EAAImG,EAAIrM,MAC5C,IAATkG,EAAG7G,EAAS,OAAOuH,EAAuByF,EAAKlG,EAAIiG,EAAI/M,MAC9C,IAAT8G,EAAG9G,EAAS,OAAOuH,EAAuBwF,EAAKlG,EAAImG,EAAIhN,OAMrD+G,EAAQR,EAAaM,EAAIC,MAClB,GAATC,EAAY,OAAO,SAEjBkG,EAAK,CAAEtM,EAAGqM,EAAIrM,EAAIoM,EAAIpM,EAAGX,EAAGgN,EAAIhN,EAAI+M,EAAI/M,GACxCkN,EAAK3G,EAAa0G,EAAIpG,GAAME,EAC5BoG,EAAK5G,EAAa0G,EAAInG,GAAMC,QAO3B,CAAEpG,GAJEoM,EAAIpM,EAAIwM,EAAKtG,EAAGlG,GAAQqM,EAAIrM,EAAIuM,EAAKpG,EAAGnG,IAE7B,EAEPX,GAHJ+M,EAAI/M,EAAImN,EAAKtG,EAAG7G,GAAQgN,EAAIhN,EAAIkN,EAAKpG,EAAG9G,IAE7B,GEuNToN,CAAab,EAAK9L,KAAKsL,SAAUU,EAAKrE,EAAM2D,iBAI5C,OAAPvE,EAAoB,KAGnBjD,EAAS+H,EAAa9E,GAGpBlB,EAAQT,MAAM2B,EAAG7G,EAAG6G,EAAGxH,GAHS,mCAkBlCyE,OACC4I,EAAY,GACZC,OAAiClI,IAAjBX,EAAMmD,OAEtB2F,EAAY,IAAI7F,EAAWjD,GAAO,GAClCgH,EAAa,IAAI/D,EAAWjD,GAAO,GACnC+I,EAAa/M,KAAK2J,aACnBqD,eAAehC,GACpB4B,EAAUnM,KAAKuK,GACf4B,EAAUnM,KAAKqM,OACTG,EAAS,IAAI1F,EACjBuF,EAAWC,EAAY/M,KAAK4J,MAAMsD,QAASlN,KAAK6J,SAASqD,gBAMvDjG,EAAWI,cAAc4F,EAAOvD,OAAO1F,MAAOiJ,EAAOtD,QAAQ3F,OAAS,GACxEiJ,EAAOE,aAELlG,EAAWI,cAAcrH,KAAK0J,OAAO1F,MAAOhE,KAAK2J,QAAQ3F,OAAS,QAC/DmJ,aAMHN,IACFC,EAAU9E,oBACVgD,EAAWhD,qBAGN4E,2CAKDQ,EAASpN,KAAK2J,aACfA,QAAU3J,KAAK0J,YACfA,OAAS0D,OACT1D,OAAOxC,QAAS,OAChByC,QAAQzC,QAAS,MACjB,IAAIlI,EAAI,EAAG8I,EAAO9H,KAAK6J,SAASnJ,OAAQ1B,EAAI8I,EAAM9I,SAChD6K,SAAS7K,KAAO,kCAMhB2I,WACH0F,EAAWrN,KACXsN,EAAW3F,EACR0F,EAASlF,YAAYkF,EAAWA,EAASlF,gBACzCmF,EAASnF,YAAYmF,EAAWA,EAASnF,eAE1C7I,EAAMiI,EAAQnH,QAAQiN,EAAUC,MAC1B,IAARhO,MAGAA,EAAO,EAAG,KACN4C,EAAMmL,EACZA,EAAWC,EACXA,EAAWpL,KAITmL,EAAS3H,OAAS4H,EAAU,KACxBpL,EAAMmL,EACZA,EAAWC,EACXA,EAAWpL,MAGR,IAAIlD,EAAI,EAAG8I,EAAOwF,EAAS1D,MAAMlJ,OAAQ1B,EAAI8I,EAAM9I,IAAK,KACrDuO,EAAOD,EAAS1D,MAAM5K,GACtBwO,EAAUF,EAASzD,SAAS7K,GAC5BqC,EAAQgM,EAASzD,MAAM6D,QAAQF,IACtB,IAAXlM,GACFgM,EAASzD,MAAMnJ,KAAK8M,GACpBF,EAASxD,SAASpJ,KAAK+M,IAEpBH,EAASxD,SAASxI,IAAUmM,EAEnCF,EAAS1D,MAAQ,KACjB0D,EAASzD,SAAW,KACpByD,EAASnF,WAAakF,EAGtBC,EAAS5D,OAAOvB,WAAakF,EAAS3D,OACtC4D,EAAS3D,QAAQxB,WAAakF,EAAS1D,4DAKZhF,IAAvB3E,KAAK0N,cAAoC1N,KAAK0N,eAC5C1N,KAAK0F,KACF1F,KAAK0F,KAAK8C,aAAcxI,KAAK0N,cAAgB1N,KAAK0F,KACtD1F,KAAK0N,cAAgB1N,KAAK0F,KAAKiI,eAFnB3N,KAAK0N,cAAgB,KAG/B1N,KAAK0N,6DAIc/I,IAAtB3E,KAAK4N,aAA4B,OAAO5N,KAAK4N,gBAC3C5N,KAAK0F,KAKN,KACGmI,EAAM7N,KAAK0F,KAAKyC,YAAcnI,KAAK0F,UACpCkI,aAAeC,EAAIC,kBAPT9N,KAAK4N,aAAe,CACnChE,MAAO,GACPC,SAAU,GACVkE,WAAY,WAMP/N,KAAK4N,0DAIajJ,IAArB3E,KAAKgO,YAA2B,OAAOhO,KAAKgO,gBAE1CC,EAAcjO,KAAKiO,mBACpBD,YAAc,CACjBpE,MAAOqE,EAAYrE,MAAMsD,MAAM,GAC/BrD,SAAUoE,EAAYpE,SAASqD,MAAM,GACrCa,WAAY,YAERG,EAAalO,KAAKgO,YAAYpE,MAC9BuE,EAAgBnO,KAAKgO,YAAYnE,SACjCuE,EAAWpO,KAAKgO,YAAYD,WAGzB/O,EAAI,EAAG8I,EAAO9H,KAAK4J,MAAMlJ,OAAQ1B,EAAI8I,EAAM9I,IAAK,KACjDuO,EAAOvN,KAAK4J,MAAM5K,GAClBwO,EAAUxN,KAAK6J,SAAS7K,GACxBqC,EAAQ6M,EAAWT,QAAQF,IAClB,IAAXlM,GACF6M,EAAWzN,KAAK8M,GAChBY,EAAc1N,KAAK+M,IAEhBW,EAAc9M,IAAUmM,UAIzBa,EAAa,GACbC,EAAe,GACZtP,EAAI,EAAG8I,EAAOoG,EAAWxN,OAAQ1B,EAAI8I,EAAM9I,OACzB,IAArBmP,EAAcnP,QACZuO,EAAOW,EAAWlP,GAClBuP,EAAOhB,EAAKgB,SACkB,IAAhCD,EAAab,QAAQc,MACrBhB,EAAKiB,WAAYH,EAAW5N,KAAK8N,OAChC,EACiC,IAAhCD,EAAab,QAAQc,IAAcD,EAAa7N,KAAK8N,OACnDlN,EAAQgN,EAAWZ,QAAQF,EAAKgB,OACvB,IAAXlN,GAAcgN,EAAWI,OAAOpN,EAAO,QAK1C,IAAIrC,EAAI,EAAG8I,EAAOuG,EAAW3N,OAAQ1B,EAAI8I,EAAM9I,IAAK,KACjD0P,EAAKL,EAAWrP,GAAG2P,WACK,IAA1BP,EAASX,QAAQiB,IAAYN,EAAS3N,KAAKiO,UAG1C1O,KAAKgO,oDAMRhO,KAAKmI,WAAY,OAAO,UAEHxD,IAArB3E,KAAK4O,YAA2B,OAAO5O,KAAK4O,gBAE1CC,EAAY7O,KAAKiO,cAAcF,WAC/BK,EAAWpO,KAAK8N,aAAaC,kBAE3Be,EAAUC,UACX,YAIGC,EAAiC,IAArBH,EAAUnO,OACtBuO,EAA+B,IAApBb,EAAS1N,YACrBkO,YAAcI,IAAcC,YAI9B,mBAKCC,EACAC,EACAN,EAAUnO,OAAS0N,EAAS1N,QAC9BwO,EAAQL,EAAUnO,OAClByO,EAAOf,EAAS1N,SAEhBwO,EAAQd,EAAS1N,OACjByO,EAAON,EAAUnO,aAEdkO,YAAcO,IAASL,EAAUM,eAAiBF,EAAQC,YAI5D,UAIGE,EAAO9M,KAAK+M,IAAIT,EAAUnO,OAAS0N,EAAS1N,aAC7CkO,YAAcS,EAAO,GAAM,YAI7B,iBAGGE,EAAgB,SAAAC,UAAsB,IAAfA,EAAI9O,QAAgB8O,EAAI,GAAGC,gBACnDb,YAAcW,EAAcV,KAAeU,EAAcnB,uBAKxD,IAAIxG,kDAA2CkH,EAAUC,cAG5D/O,KAAK4O,+CAxaEtC,EAAKC,EAAKgB,OACpBmC,EAAQC,EAASnC,EAGfoC,EAAS3I,EAAWI,cAAciF,EAAKC,MACzCqD,EAAS,EACXF,EAASpD,EACTqD,EAAUpD,EACViB,EAAU,MAEP,CAAA,KAAIoC,EAAS,GAKb,MAAM,IAAIhI,uDAC6B0E,EAAIpM,eAAMoM,EAAI/M,QALxDmQ,EAASnD,EACToD,EAAUrD,EACVkB,GAAW,SAQN,IAAIjG,EAFI,IAAIN,EAAWyI,GAAQ,GACtB,IAAIzI,EAAW0I,GAAS,GACJ,CAACpC,GAAO,CAACC,aCzKpCqC,EAAb,sBACeC,EAAUvB,EAAMC,iBACtBuB,MAAMC,QAAQF,IAAiC,IAApBA,EAASpP,aACjC,IAAIkH,MAAM,iEAGb2G,KAAOA,OACPC,WAAaA,OACbyB,SAAW,GAEc,iBAAnBH,EAAS,GAAG,IAA6C,iBAAnBA,EAAS,GAAG,SACrD,IAAIlI,MAAM,6DAGZsI,EAAarK,EAAQT,MAAM0K,EAAS,GAAG,GAAIA,EAAS,GAAG,SACxD/L,KAAO,CACVE,GAAI,CAAE/D,EAAGgQ,EAAWhQ,EAAGX,EAAG2Q,EAAW3Q,GACrC2E,GAAI,CAAEhE,EAAGgQ,EAAWhQ,EAAGX,EAAG2Q,EAAW3Q,YAGnC4Q,EAAYD,EACPlR,EAAI,EAAG8I,EAAOgI,EAASpP,OAAQ1B,EAAI8I,EAAM9I,IAAK,IACvB,iBAAnB8Q,EAAS9Q,GAAG,IAA6C,iBAAnB8Q,EAAS9Q,GAAG,SACrD,IAAI4I,MAAM,6DAEd5D,EAAQ6B,EAAQT,MAAM0K,EAAS9Q,GAAG,GAAI8Q,EAAS9Q,GAAG,IAElDgF,EAAM9D,IAAMiQ,EAAUjQ,GAAK8D,EAAMzE,IAAM4Q,EAAU5Q,SAChD0Q,SAASxP,KAAK8G,EAAQ6I,SAASD,EAAWnM,EAAOhE,OAClDgE,EAAM9D,EAAIF,KAAK+D,KAAKE,GAAG/D,IAAGF,KAAK+D,KAAKE,GAAG/D,EAAI8D,EAAM9D,GACjD8D,EAAMzE,EAAIS,KAAK+D,KAAKE,GAAG1E,IAAGS,KAAK+D,KAAKE,GAAG1E,EAAIyE,EAAMzE,GACjDyE,EAAM9D,EAAIF,KAAK+D,KAAKG,GAAGhE,IAAGF,KAAK+D,KAAKG,GAAGhE,EAAI8D,EAAM9D,GACjD8D,EAAMzE,EAAIS,KAAK+D,KAAKG,GAAG3E,IAAGS,KAAK+D,KAAKG,GAAG3E,EAAIyE,EAAMzE,GACrD4Q,EAAYnM,GAGVkM,EAAWhQ,IAAMiQ,EAAUjQ,GAAKgQ,EAAW3Q,IAAM4Q,EAAU5Q,QACxD0Q,SAASxP,KAAK8G,EAAQ6I,SAASD,EAAWD,EAAYlQ,kEAKvDqQ,EAAc,GACXrR,EAAI,EAAG8I,EAAO9H,KAAKiQ,SAASvP,OAAQ1B,EAAI8I,EAAM9I,IAAK,KACpDwI,EAAUxH,KAAKiQ,SAASjR,GAC9BqR,EAAY5P,KAAK+G,EAAQkC,QACzB2G,EAAY5P,KAAK+G,EAAQmC,gBAEpB0G,QAhDX,GAoDaC,EAAb,sBACeC,EAAU5B,iBAChBoB,MAAMC,QAAQO,SACX,IAAI3I,MAAM,8DAEb4I,aAAe,IAAIX,EAAOU,EAAS,GAAIvQ,MAAM,QAE7C+D,KAAO,CACVE,GAAI,CAAE/D,EAAGF,KAAKwQ,aAAazM,KAAKE,GAAG/D,EAAGX,EAAGS,KAAKwQ,aAAazM,KAAKE,GAAG1E,GACnE2E,GAAI,CAAEhE,EAAGF,KAAKwQ,aAAazM,KAAKG,GAAGhE,EAAGX,EAAGS,KAAKwQ,aAAazM,KAAKG,GAAG3E,SAEhEkR,cAAgB,OAChB,IAAIzR,EAAI,EAAG8I,EAAOyI,EAAS7P,OAAQ1B,EAAI8I,EAAM9I,IAAK,KAC/CuO,EAAO,IAAIsC,EAAOU,EAASvR,GAAIgB,MAAM,GACvCuN,EAAKxJ,KAAKE,GAAG/D,EAAIF,KAAK+D,KAAKE,GAAG/D,IAAGF,KAAK+D,KAAKE,GAAG/D,EAAIqN,EAAKxJ,KAAKE,GAAG/D,GAC/DqN,EAAKxJ,KAAKE,GAAG1E,EAAIS,KAAK+D,KAAKE,GAAG1E,IAAGS,KAAK+D,KAAKE,GAAG1E,EAAIgO,EAAKxJ,KAAKE,GAAG1E,GAC/DgO,EAAKxJ,KAAKG,GAAGhE,EAAIF,KAAK+D,KAAKG,GAAGhE,IAAGF,KAAK+D,KAAKG,GAAGhE,EAAIqN,EAAKxJ,KAAKG,GAAGhE,GAC/DqN,EAAKxJ,KAAKG,GAAG3E,EAAIS,KAAK+D,KAAKG,GAAG3E,IAAGS,KAAK+D,KAAKG,GAAG3E,EAAIgO,EAAKxJ,KAAKG,GAAG3E,QAC9DkR,cAAchQ,KAAK8M,QAErBoB,UAAYA,6DAIX0B,EAAcrQ,KAAKwQ,aAAaE,iBAC7B1R,EAAI,EAAG8I,EAAO9H,KAAKyQ,cAAc/P,OAAQ1B,EAAI8I,EAAM9I,YACpD2R,EAAkB3Q,KAAKyQ,cAAczR,GAAG0R,iBACrCzO,EAAI,EAAG2O,EAAOD,EAAgBjQ,OAAQuB,EAAI2O,EAAM3O,IACvDoO,EAAY5P,KAAKkQ,EAAgB1O,WAG9BoO,QA/BX,GAmCaQ,EAAb,sBACeC,EAAMrB,iBACZM,MAAMC,QAAQc,SACX,IAAIlJ,MAAM,6DAKa,iBAAlBkJ,EAAK,GAAG,GAAG,KAAiBA,EAAO,CAACA,IAC/C,MAAOC,SAKJC,MAAQ,QACRjN,KAAO,CACVE,GAAI,CAAE/D,EAAGuE,OAAOwM,kBAAmB1R,EAAGkF,OAAOwM,mBAC7C/M,GAAI,CAAEhE,EAAGuE,OAAOyM,kBAAmB3R,EAAGkF,OAAOyM,wBAE1C,IAAIlS,EAAI,EAAG8I,EAAOgJ,EAAKpQ,OAAQ1B,EAAI8I,EAAM9I,IAAK,KAC3CuP,EAAO,IAAI+B,EAAOQ,EAAK9R,GAAIgB,MAC7BuO,EAAKxK,KAAKE,GAAG/D,EAAIF,KAAK+D,KAAKE,GAAG/D,IAAGF,KAAK+D,KAAKE,GAAG/D,EAAIqO,EAAKxK,KAAKE,GAAG/D,GAC/DqO,EAAKxK,KAAKE,GAAG1E,EAAIS,KAAK+D,KAAKE,GAAG1E,IAAGS,KAAK+D,KAAKE,GAAG1E,EAAIgP,EAAKxK,KAAKE,GAAG1E,GAC/DgP,EAAKxK,KAAKG,GAAGhE,EAAIF,KAAK+D,KAAKG,GAAGhE,IAAGF,KAAK+D,KAAKG,GAAGhE,EAAIqO,EAAKxK,KAAKG,GAAGhE,GAC/DqO,EAAKxK,KAAKG,GAAG3E,EAAIS,KAAK+D,KAAKG,GAAG3E,IAAGS,KAAK+D,KAAKG,GAAG3E,EAAIgP,EAAKxK,KAAKG,GAAG3E,QAC9DyR,MAAMvQ,KAAK8N,QAEbkB,UAAYA,6DAIXY,EAAc,GACXrR,EAAI,EAAG8I,EAAO9H,KAAKgR,MAAMtQ,OAAQ1B,EAAI8I,EAAM9I,YAC5CmS,EAAkBnR,KAAKgR,MAAMhS,GAAG0R,iBAC7BzO,EAAI,EAAG2O,EAAOO,EAAgBzQ,OAAQuB,EAAI2O,EAAM3O,IACvDoO,EAAY5P,KAAK0Q,EAAgBlP,WAG9BoO,QAtCX,GCvFae,EAAb,sBAiFejK,kBACNA,OAASA,MACT,IAAInI,EAAI,EAAG8I,EAAOX,EAAOzG,OAAQ1B,EAAI8I,EAAM9I,IAC9CmI,EAAOnI,GAAGwI,QAAQe,QAAUvI,UAEzBuO,KAAO,oDAnFE8C,WACRC,EAAW,GAERtS,EAAI,EAAG8I,EAAOuJ,EAAY3Q,OAAQ1B,EAAI8I,EAAM9I,IAAK,KAClDwI,EAAU6J,EAAYrS,MACvBwI,EAAQgB,eAAgBhB,EAAQe,iBAEjCgJ,EAAY,KACZC,EAAQhK,EAAQkC,OAChBZ,EAAYtB,EAAQmC,QAClBxC,EAAS,CAACqK,GAEVC,EAAgBD,EAAMxN,MACtB0N,EAAkB,GAItBH,EAAYC,EACZA,EAAQ1I,EACR3B,EAAO1G,KAAK+Q,GAGRA,EAAMxN,QAAUyN,UAEP,KACLE,EAAeH,EAAMI,8BAIC,IAAxBD,EAAajR,OAAc,KACvBmR,EAAU1K,EAAO,GAAGnD,MACpB8N,EAAS3K,EAAOA,EAAOzG,OAAS,GAAGsD,YACnC,IAAI4D,MACR,sDAA+CiK,EAAQ3R,kBACjD2R,EAAQtS,wDACPuS,EAAO5R,eAAM4R,EAAOvS,YAKH,IAAxBoS,EAAajR,OAAc,CAC7BoI,EAAY6I,EAAa,GAAGtJ,sBAK1B0J,EAAU,KACL9P,EAAI,EAAG2O,EAAOc,EAAgBhR,OAAQuB,EAAI2O,EAAM3O,OACnDyP,EAAgBzP,GAAG+B,QAAUwN,EAAMxN,MAAO,CAC5C+N,EAAU9P,WAKE,OAAZ8P,GAQJL,EAAgBjR,KAAK,CACnBY,MAAO8F,EAAOzG,OACdsD,MAAOwN,EAAMxN,YAGT9E,EAAasS,EAAMQ,sBAAsBT,GAC/CzI,EAAY6I,EAAa5P,KAAK7C,GAAY,GAAGmJ,kBAbrC4J,EAAiBP,EAAgBjD,OAAOsD,GAAS,GACjDG,EAAa/K,EAAOsH,OAAOwD,EAAe5Q,OAChD6Q,EAAWC,QAAQD,EAAW,GAAG7J,SACjCiJ,EAAS7Q,KAAK,IAAI2Q,EAAQc,EAAWE,YAe3Cd,EAAS7Q,KAAK,IAAI2Q,EAAQjK,YAErBmK,mDAaHe,EAASrS,KAAKmH,OAAO,GAAGnD,MACtBsO,EAAS,CAACD,GACPrT,EAAI,EAAG8I,EAAO9H,KAAKmH,OAAOzG,OAAS,EAAG1B,EAAI8I,EAAM9I,IAAK,KACtD+H,EAAK/G,KAAKmH,OAAOnI,GAAGgF,MACpBuO,EAASvS,KAAKmH,OAAOnI,EAAI,GAAGgF,MACc,IAA5CgC,EAAoBe,EAAIsL,EAAQE,KACpCD,EAAO7R,KAAKsG,GACZsL,EAAStL,MAIW,IAAlBuL,EAAO5R,OAAc,OAAO,SAG1BqG,EAAKuL,EAAO,GACZC,EAASD,EAAO,GAC0B,IAA5CtM,EAAoBe,EAAIsL,EAAQE,IAAeD,EAAOE,QAE1DF,EAAO7R,KAAK6R,EAAO,YACbG,EAAOzS,KAAK0S,iBAAmB,GAAK,EACpCC,EAAS3S,KAAK0S,iBAAmB,EAAIJ,EAAO5R,OAAS,EACrDkS,EAAO5S,KAAK0S,iBAAmBJ,EAAO5R,QAAU,EAChDmS,EAAgB,GACb7T,EAAI2T,EAAQ3T,GAAK4T,EAAM5T,GAAKyT,EAAMI,EAAcpS,KAAK,CAAC6R,EAAOtT,GAAGkB,EAAGoS,EAAOtT,GAAGO,WAC/EsT,mDAIsBlO,IAAzB3E,KAAK8S,gBAA+B,KAChCC,EAAY/S,KAAKgT,qBAClBF,iBAAkBC,IAAcA,EAAUL,wBAE1C1S,KAAK8S,oEAIgBnO,IAAxB3E,KAAKiT,sBACFA,eAAiBjT,KAAKkT,sBAEtBlT,KAAKiT,oEAORE,EAAcnT,KAAKmH,OAAO,GACrBnI,EAAI,EAAG8I,EAAO9H,KAAKmH,OAAOzG,OAAQ1B,EAAI8I,EAAM9I,IAAK,KAClD+I,EAAM/H,KAAKmH,OAAOnI,GACpBiI,EAAW7G,QAAQ+S,EAAapL,GAAO,IAAGoL,EAAcpL,WAG1DqL,EAAUD,EAAY3L,QAAQmG,eAC9B0F,EAAcD,EAAUA,EAAQzF,eAAiB,OAExC,KAENyF,EAAS,OAAO,SAIhBC,EAAa,OAAOD,EAAQ7K,WAK7B8K,EAAY9K,UAAY6K,EAAQ7K,eAC9B8K,EAAY9K,QAAQyK,kBAAoBI,EAAQ7K,QAC3C6K,EAAQ7K,QACH6K,EAAQ7K,QAAQyK,gBAKhCI,EAAUC,EAAY1F,eACtB0F,EAAcD,EAAUA,EAAQzF,eAAiB,YAtKvD,GA2Ka2F,EAAb,sBACe9C,kBACNA,aAAeA,EACpBA,EAAajC,KAAOvO,UACfyQ,cAAgB,iDAGVlD,QACNkD,cAAchQ,KAAK8M,GACxBA,EAAKgB,KAAOvO,2CAIN8Q,EAAO,CAAC9Q,KAAKwQ,aAAa+C,cAEhB,OAAZzC,EAAK,GAAa,OAAO,SACxB,IAAI9R,EAAI,EAAG8I,EAAO9H,KAAKyQ,cAAc/P,OAAQ1B,EAAI8I,EAAM9I,IAAK,KACzDwU,EAAWxT,KAAKyQ,cAAczR,GAAGuU,UAEtB,OAAbC,GACJ1C,EAAKrQ,KAAK+S,UAEL1C,QAtBX,GA0Ba2C,EAAb,sBACe7J,kBACNA,MAAQA,OACRoH,MAAQhR,KAAK0T,cAAc9J,uDAI1BkH,EAAO,GACJ9R,EAAI,EAAG8I,EAAO9H,KAAKgR,MAAMtQ,OAAQ1B,EAAI8I,EAAM9I,IAAK,KACjD2U,EAAW3T,KAAKgR,MAAMhS,GAAGuU,UAEd,OAAbI,GACJ7C,EAAKrQ,KAAKkT,UAEL7C,wCAGMlH,WACPoH,EAAQ,GACLhS,EAAI,EAAG8I,EAAO8B,EAAMlJ,OAAQ1B,EAAI8I,EAAM9I,IAAK,KAC5CuO,EAAO3D,EAAM5K,OACfuO,EAAKgB,QACLhB,EAAKmF,iBAAkB1B,EAAMvQ,KAAK,IAAI6S,EAAQ/F,QAC7C,KACGyF,EAAgBzF,EAAKyF,gBACtBA,EAAczE,MAAMyC,EAAMvQ,KAAK,IAAI6S,EAAQN,IAChDA,EAAczE,KAAKqF,YAAYrG,WAG5ByD,QA7BX,GCzLqB6C,wBACNC,OAAO5U,yDAAaqI,EAAQnH,uBAClC0T,MAAQA,OACRzO,KAAO,IAAIC,EAAUpG,QACrB+Q,SAAW,6CAGTuB,OACDhK,EAAUgK,EAAMhK,QAChBoF,EAAY,MAId4E,EAAMrJ,kBACJqJ,EAAMtK,OAAQlH,KAAK8T,MAAMnO,OAAO6L,EAAMnJ,SACrCrI,KAAKqF,KAAKM,OAAO6B,GACfoF,MAGHnN,EAAO+R,EAAMtK,OACflH,KAAKqF,KAAK7F,OAAOgI,GACjBxH,KAAKqF,KAAK0O,KAAKvM,OAEb/H,EAAM,MAAM,IAAImI,MACpB,kCAA2BJ,EAAQsC,mBAC/BtC,EAAQkC,OAAO1F,MAAM9D,eAAMsH,EAAQkC,OAAO1F,MAAMzE,sBAChDiI,EAAQmC,QAAQ3F,MAAM9D,eAAMsH,EAAQmC,QAAQ3F,MAAMzE,QACtD,0DAGEkG,EAAWhG,EACXmG,EAAWnG,EACX2T,OAAUzO,EACVqP,OAAUrP,OAGKA,IAAZyO,GAEY,QADjB3N,EAAWzF,KAAKqF,KAAKK,KAAKD,IACH2N,EAAU,UACIzO,IAA5Bc,EAASlH,IAAI4J,aAA0BiL,EAAU3N,EAASlH,eAIlDoG,IAAZqP,GAEY,QADjBpO,EAAW5F,KAAKqF,KAAK5G,KAAKmH,IACHoO,EAAU,UACIrP,IAA5BiB,EAASrH,IAAI4J,aAA0B6L,EAAUpO,EAASrH,QAGjEiT,EAAMtK,OAAQ,KAGZ+M,EAAiB,QACjBb,EAAS,KACLc,EAAYd,EAAQe,gBAAgB3M,MACxB,OAAd0M,IACG1M,EAAQ2D,aAAa+I,KAAYD,EAAiBC,IAClDd,EAAQjI,aAAa+I,YAClBE,EAAqBpU,KAAKqU,aAAajB,EAASc,GAC7ClV,EAAI,EAAG8I,EAAOsM,EAAmB1T,OAAQ1B,EAAI8I,EAAM9I,IAC1D4N,EAAUnM,KAAK2T,EAAmBpV,QAOtCsV,EAAiB,QACjBN,EAAS,KACLO,EAAYP,EAAQG,gBAAgB3M,MACxB,OAAd+M,IACG/M,EAAQ2D,aAAaoJ,KAAYD,EAAiBC,IAClDP,EAAQ7I,aAAaoJ,YAClBH,EAAqBpU,KAAKqU,aAAaL,EAASO,GAC7CvV,EAAI,EAAG8I,EAAOsM,EAAmB1T,OAAQ1B,EAAI8I,EAAM9I,IAC1D4N,EAAUnM,KAAK2T,EAAmBpV,OASnB,OAAnBiV,GAA8C,OAAnBK,EAAyB,KAElDE,EAAa,QACM,OAAnBP,EAAyBO,EAAaF,OACrC,GAAuB,OAAnBA,EAAyBE,EAAaP,MAC1C,CAEHO,EADqBvN,EAAWI,cAAc4M,EAAgBK,IACjC,EAAIL,EAAiBK,OAK/CR,MAAMnO,OAAO6B,EAAQmC,SAC1BiD,EAAUnM,KAAK+G,EAAQmC,iBAEjByK,EAAqB5M,EAAQ9H,MAAM8U,GAChCxV,EAAI,EAAG8I,EAAOsM,EAAmB1T,OAAQ1B,EAAI8I,EAAM9I,IAC1D4N,EAAUnM,KAAK2T,EAAmBpV,IAIlC4N,EAAUlM,OAAS,QAIhB2E,KAAKM,OAAO6B,GACjBoF,EAAUnM,KAAK+Q,UAIVvB,SAASxP,KAAK+G,GACnBA,EAAQ9B,KAAO0N,OAGZ,IAKDA,GAAWY,EAAS,KAChBS,EAAQrB,EAAQe,gBAAgBH,MACxB,OAAVS,EAAgB,KACbrB,EAAQjI,aAAasJ,WAClBL,EAAqBpU,KAAKqU,aAAajB,EAASqB,GAC7CzV,EAAI,EAAG8I,EAAOsM,EAAmB1T,OAAQ1B,EAAI8I,EAAM9I,IAC1D4N,EAAUnM,KAAK2T,EAAmBpV,QAGjCgV,EAAQ7I,aAAasJ,WAClBL,EAAqBpU,KAAKqU,aAAaL,EAASS,GAC7CzV,EAAI,EAAG8I,EAAOsM,EAAmB1T,OAAQ1B,EAAI8I,EAAM9I,IAC1D4N,EAAUnM,KAAK2T,EAAmBpV,UAMrCqG,KAAKM,OAAO6B,UAGZoF,uCAKIiB,EAAK9G,QAKX1B,KAAKM,OAAOkI,OACXlE,EAAUkE,EAAIlE,aACfmK,MAAMnO,OAAOgE,OACZiD,EAAYiB,EAAInO,MAAMqH,UAC5B6F,EAAUnM,KAAKkJ,QAEQhF,IAAnBkJ,EAAI1F,YAA0BnI,KAAKqF,KAAK7F,OAAOqO,GAC5CjB,WClFLkC,EAAY,IAtFlB,wEACOC,EAAM+B,EAAM4D,GACf5F,EAAUC,KAAOA,EACjBlJ,EAAQb,gBAGF2P,EAAa,CAAC,IAAIC,EAAmB9D,GAAM,IACxC9R,EAAI,EAAG8I,EAAO4M,EAAUhU,OAAQ1B,EAAI8I,EAAM9I,IACjD2V,EAAWlU,KAAK,IAAImU,EAAmBF,EAAU1V,IAAI,OAEvD8P,EAAUM,cAAgBuF,EAAWjU,OAMd,eAAnBoO,EAAUC,aAEN8F,EAAUF,EAAW,GACvB3V,EAAI,EACDA,EAAI2V,EAAWjU,QACqC,OAArDyD,EAAewQ,EAAW3V,GAAG+E,KAAM8Q,EAAQ9Q,MAAgB/E,IAC1D2V,EAAWlG,OAAOzP,EAAG,MAOP,iBAAnB8P,EAAUC,SAGP,IAAI/P,EAAI,EAAG8I,EAAO6M,EAAWjU,OAAQ1B,EAAI8I,EAAM9I,YAC5C8V,EAAMH,EAAW3V,GACdiD,EAAIjD,EAAI,EAAG4R,EAAO+D,EAAWjU,OAAQuB,EAAI2O,EAAM3O,OACD,OAAjDkC,EAAe2Q,EAAI/Q,KAAM4Q,EAAW1S,GAAG8B,MAAgB,MAAO,WAMlE+P,EAAQ,IAAIxO,EAAU2B,EAAW7G,SAC9BpB,EAAI,EAAG8I,EAAO6M,EAAWjU,OAAQ1B,EAAI8I,EAAM9I,YAC5CqR,EAAcsE,EAAW3V,GAAG0R,iBACzBzO,EAAI,EAAG2O,EAAOP,EAAY3P,OAAQuB,EAAI2O,EAAM3O,IACnD6R,EAAMtU,OAAO6Q,EAAYpO,YAKvB8S,EAAY,IAAIlB,EAAUC,GAC5BkB,EAAgBlB,EAAMhS,KACtBrC,EAAOqU,EAAMnT,MACVlB,GAAM,KACLsI,EAAMtI,EAAKlB,OACbuV,EAAMhS,OAASkT,EAAe,KAE1BnH,EAAM9F,EAAIP,cACV,IAAII,MACR,0BAAmBG,EAAIb,OAAS,OAAS,mCACrCa,EAAI/D,MAAM9D,eAAM6H,EAAI/D,MAAMzE,6BAAoBsO,EAAI/D,mBAClD+D,EAAInE,OAAO1F,MAAM9D,eAAM2N,EAAInE,OAAO1F,MAAMzE,sBACxCsO,EAAIlE,QAAQ3F,MAAM9D,eAAM2N,EAAIlE,QAAQ3F,MAAMzE,oBAC9C,qCAGEqN,EAAYmI,EAAUE,QAAQlN,GAC3B/I,EAAI,EAAG8I,EAAO8E,EAAUlM,OAAQ1B,EAAI8I,EAAM9I,IAAK,KAChD+I,EAAM6E,EAAU5N,QACC2F,IAAnBoD,EAAII,YAA0B2L,EAAMtU,OAAOuI,GAEjDiN,EAAgBlB,EAAMhS,KACtBrC,EAAOqU,EAAMnT,MAIfkF,EAAQb,YAGFsM,EAAW4D,EAAgBC,QAAQJ,EAAU9E,iBACpC,IAAIiF,EAAqB5D,GAC1BiC,gBAjFlB,UCMe,CACb6B,MAbY,SAACtE,8BAAS4D,mCAAAA,2BACtB5F,EAAUuG,IAAI,QAASvE,EAAM4D,IAa7B/H,aAXmB,SAACmE,8BAAS4D,mCAAAA,2BAC7B5F,EAAUuG,IAAI,eAAgBvE,EAAM4D,IAWpCY,IATU,SAACxE,8BAAS4D,mCAAAA,2BACpB5F,EAAUuG,IAAI,MAAOvE,EAAM4D,IAS3Ba,WAPiB,SAACC,8BAAgBC,mCAAAA,2BAClC3G,EAAUuG,IAAI,aAAcG,EAAaC"}